#+TITLE: BMACS Configuration
#+AUTHOR: Bryan Gilbert
#+PROPERTY: header-args :tangle yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything

* Configuration

** About this file
   :PROPERTIES:
   :CUSTOM_ID: babel-init
   :END:
<<babel-init>>

This is Bryan Gilbert's personal Emacs configuration.

** Personal Information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Bryan Gilbert"
      user-mail-address "bryan@bryan.sh"
      auth-sources (list (expand-file-name "~/.authinfo.gpg")))
#+END_SRC

*** TODO Maybe load some info from a secret emacs file? Mail stuff here?

** Variables

*** Directories

We're going to define a number of directories that are used throughout this configuration to store
different types of files.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar bmacs-emacs-dir (expand-file-name user-emacs-directory)
    "The path to the emacs.d directory.")

  (defvar bmacs-local-dir (concat bmacs-emacs-dir ".local/")
    "Root directory for local Emacs files. Use this as permanent storage for files
  that are safe to share across systems (if this config is symlinked across
  several computers).")

  (defvar bmacs-host-dir (concat bmacs-local-dir "@" (system-name))
    "Directory for hostname-specific file storage. Used by `bmacs-etc-dir' and
  `bmacs-cache-dir'.")

  (defvar bmacs-etc-dir (concat bmacs-host-dir "/etc/")
    "Host-namespaced directory for non-volatile storage. These are not deleted or
  tampored with by BMACS functions. Use this for dependencies like servers or
  config files that are stable (i.e. it should be unlikely that you need to delete
  them if something goes wrong).")

  (defvar bmacs-cache-dir (concat bmacs-host-dir "/cache/")
    "Host-namespaced directory for volatile storage. Deleted when `bmacs/reset' is
  called. Use this for transient files that are generated on the fly like caches
  and temporary files. Anything that may need to be cleared if there are
  problems.")

  (defvar bmacs-packages-dir (concat bmacs-local-dir "packages/")
    "Where package.el and quelpa plugins (and their caches) are stored."))


(dolist (dir (list bmacs-local-dir bmacs-etc-dir bmacs-cache-dir (expand-file-name "elpa" bmacs-packages-dir)))
  (unless (file-directory-p dir)
    (make-directory dir t)))
#+END_SRC

*** Hooks

#+BEGIN_SRC emacs-lisp
(defvar bmacs-post-init-hook nil
  "A list of hooks run after BMACS initialization is complete, and after
`bmacs-init-hook'.")
#+END_SRC

** Emacs Initialization

TODO - Maybe look into adding external elisp folder?

*** Initialization Settings

Let's start emacs up quietly.

#+BEGIN_SRC emacs-lisp
(advice-add #'display-startup-echo-area-message :override #'ignore)
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil
      mode-line-format nil)
#+END_SRC

We're going to increase the gc-cons-threshold to a very high number to decrease the load time. We're
going to add a hook to reset this value after initialization

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))

(add-hook 'bmacs-post-init-hook #'(lambda () (setq gc-cons-threshold 16777216
                                                   gc-cons-percentage 0.1)))
#+END_SRC

Let's increase the =max-lisp-eval-depth= and =max-specpdl-size= to prevent exceeding recursion limits.

#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 50000)
(setq max-specpdl-size 10000)
#+END_SRC

Now, we're going to disable double-buffering to prevent stuttering.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC

We want to store any custom set variables in a separate =custom.el= file to prevent custom variables
from being written to our =init.el= file.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC

*** Initialize and Add Package Sources

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq use-package-always-defer t
      use-package-verbose t
      use-package-always-ensure t
      use-package-minimum-reported-time 0.1)

(setq quelpa-checkout-melpa-p nil
      quelpa-update-melpa-p nil
      quelpa-melpa-recipe-stores nil
      quelpa-self-upgrade-p nil)

(eval-and-compile
  (setq package-user-dir (expand-file-name "elpa" bmacs-packages-dir)))

(setq load-prefer-newer t
      package-enable-at-startup nil)

(setq quelpa-dir (expand-file-name "quelpa" bmacs-packages-dir))

(unless (assoc-default "melpa" package-archives)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t))
(unless (assoc-default "org" package-archives)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))
(eval-and-compile
  (package-initialize))
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu/mu4e")
#+END_SRC

Use =M-x package-refresh-contents= to reload the list of packages
after adding these for the first time.

*** Setup Use-Package

Install =use-package= if it isn't already installed, enable it, and turn on auto-compiling. Also,
configured =use-package= to always defer a package by default.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(use-package auto-compile
  :demand t
  :config (auto-compile-on-load-mode))
#+END_SRC


*** Setup Quelpa

#+BEGIN_SRC emacs-lisp
(setq quelpa-update-melpa-p nil)
(unless (require 'quelpa nil t)
  (with-temp-buffer
    (url-insert-file-contents "http://raw.github.com/quelpa/quelpa/master/bootstrap.el")
    (eval-buffer)))

(quelpa
 '(quelpa-use-package
   :fetcher github
   :repo "quelpa/quelpa-use-package"))
(require 'quelpa-use-package)
#+END_SRC

** Security Settings

#+BEGIN_SRC emacs-lisp
(setq gnutls-verify-error t
      tls-checktrust gnutls-verify-error
      tls-program (list "gnutls-cli --x509cafile %t -p %p %h"
                        ;; compatibility fallbacks
                        "gnutls-cli -p %p %h"
                        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof"))
#+END_SRC

** Macros

*** after!

#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC

*** map!
An amazing keybinding macro written by hlissner

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun bmacs-enlist (exp)
    "Return EXP wrapped in a list, or as-is if already a list."
    (if (listp exp) exp (list exp)))

  (defun doom-unquote (exp)
    "Return EXP unquoted."
    (while (memq (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)

  (defvar bmacs-leader-key "SPC"
    "The leader prefix key, for global commands.")

  (defvar bmacs-localleader-key "SPC m"
    "The localleader prefix key, for major-mode specific commands.")

  (defvar bmacs-evil-state-alist
    '((?n . normal)
      (?v . visual)
      (?i . insert)
      (?e . emacs)
      (?o . operator)
      (?m . motion)
      (?r . replace))
    "A list of cons cells that map a letter to a evil state symbol.")

  ;; Register keywords for proper indentation (see `map!')
  (put ':after        'lisp-indent-function 'defun)
  (put ':desc         'lisp-indent-function 'defun)
  (put ':leader       'lisp-indent-function 'defun)
  (put ':local        'lisp-indent-function 'defun)
  (put ':localleader  'lisp-indent-function 'defun)
  (put ':map          'lisp-indent-function 'defun)
  (put ':map*         'lisp-indent-function 'defun)
  (put ':mode         'lisp-indent-function 'defun)
  (put ':prefix       'lisp-indent-function 'defun)
  (put ':textobj      'lisp-indent-function 'defun)
  (put ':unless       'lisp-indent-function 'defun)
  (put ':when         'lisp-indent-function 'defun)

;; specials
  (defvar bmacs--keymaps nil)
  (defvar bmacs--prefix  nil)
  (defvar bmacs--defer   nil)
  (defvar bmacs--local   nil)

(defun bmacs--keybind-register (key desc &optional modes)
  "Register a description for KEY with `which-key' in MODES.

  KEYS should be a string in kbd format.
  DESC should be a string describing what KEY does.
  MODES should be a list of major mode symbols."
  (if modes
      (dolist (mode modes)
        (which-key-add-major-mode-key-based-replacements mode key desc))
    (which-key-add-key-based-replacements key desc)))

(defun bmacs--keyword-to-states (keyword)
  "Convert a KEYWORD into a list of evil state symbols.

For example, :nvi will map to (list 'normal 'visual 'insert). See
`bmacs-evil-state-alist' to customize this."
  (cl-loop for l across (substring (symbol-name keyword) 1)
           if (cdr (assq l bmacs-evil-state-alist))
             collect it
           else
             do (error "not a valid state: %s" l)))

(defmacro map! (&rest rest)
  "A nightmare of a key-binding macro that will use `evil-define-key*',
`define-key', `local-set-key' and `global-set-key' depending on context and
plist key flags (and whether evil is loaded or not). It was designed to make
binding multiple keys more concise, like in vim.

If evil isn't loaded, it will ignore evil-specific bindings.

States
    :n  normal
    :v  visual
    :i  insert
    :e  emacs
    :o  operator
    :m  motion
    :r  replace

    These can be combined (order doesn't matter), e.g. :nvi will apply to
    normal, visual and insert mode. The state resets after the following
    key=>def pair.

    If states are omitted the keybind will be global.

    This can be customized with `bmacs-evil-state-alist'.

    :textobj is a special state that takes a key and two commands, one for the
    inner binding, another for the outer.

Flags
    (:mode [MODE(s)] [...])    inner keybinds are applied to major MODE(s)
    (:map [KEYMAP(s)] [...])   inner keybinds are applied to KEYMAP(S)
    (:map* [KEYMAP(s)] [...])  same as :map, but deferred
    (:prefix [PREFIX] [...])   assign prefix to all inner keybindings
    (:after [FEATURE] [...])   apply keybinds when [FEATURE] loads
    (:local [...])             make bindings buffer local; incompatible with keymaps!

Conditional keybinds
    (:when [CONDITION] [...])
    (:unless [CONDITION] [...])

Example
    (map! :map magit-mode-map
          :m \"C-r\" 'do-something           ; assign C-r in motion state
          :nv \"q\" 'magit-mode-quit-window  ; assign to 'q' in normal and visual states
          \"C-x C-r\" 'a-global-keybind

          (:when IS-MAC
           :n \"M-s\" 'some-fn
           :i \"M-o\" (lambda (interactive) (message \"Hi\"))))"
  (let ((bmacs--keymaps bmacs--keymaps)
        (bmacs--prefix  bmacs--prefix)
        (bmacs--defer   bmacs--defer)
        (bmacs--local   bmacs--local)
        key def states forms desc modes)
    (while rest
      (setq key (pop rest))
      (cond
       ;; it's a sub expr
       ((listp key)
        (push (macroexpand `(map! ,@key)) forms))

       ;; it's a flag
       ((keywordp key)
        (cond ((eq key :leader)
               (push 'bmacs-leader-key rest)
               (setq key :prefix
                     desc "<leader>"))
              ((eq key :localleader)
               (push 'bmacs-localleader-key rest)
               (setq key :prefix
                     desc "<localleader>")))
        (pcase key
          (:when    (push `(if ,(pop rest)       ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
          (:unless  (push `(if (not ,(pop rest)) ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
          (:after   (push `(after! ,(pop rest)   ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
          (:desc    (setq desc (pop rest)))
          (:map*    (setq bmacs--defer t) (push :map rest))
          (:map
            (setq bmacs--keymaps (bmacs-enlist (pop rest))))
          (:mode
            (setq modes (bmacs-enlist (pop rest)))
            (unless bmacs--keymaps
              (setq bmacs--keymaps
                    (cl-loop for m in modes
                             collect (intern (format "%s-map" (symbol-name m)))))))
          (:textobj
            (let* ((key (pop rest))
                   (inner (pop rest))
                   (outer (pop rest)))
              (push (macroexpand `(map! (:map evil-inner-text-objects-map ,key ,inner)
                                        (:map evil-outer-text-objects-map ,key ,outer)))
                    forms)))
          (:prefix
            (let ((def (pop rest)))
              (setq bmacs--prefix `(vconcat ,bmacs--prefix (kbd ,def)))
              (when desc
                (push `(bmacs--keybind-register ,(key-description (eval bmacs--prefix))
                                                ,desc ',modes)
                      forms)
                (setq desc nil))))
          (:local
           (setq bmacs--local t))
          (_ ; might be a state bmacs--prefix
           (setq states (bmacs--keyword-to-states key)))))

       ;; It's a key-def pair
       ((or (stringp key)
            (characterp key)
            (vectorp key)
            (symbolp key))
        (unwind-protect
            (catch 'skip
              (when (symbolp key)
                (setq key `(kbd ,key)))
              (when (stringp key)
                (setq key (kbd key)))
              (when bmacs--prefix
                (setq key (append bmacs--prefix (list key))))
              (unless (> (length rest) 0)
                (user-error "map! has no definition for %s key" key))
              (setq def (pop rest))
              (when desc
                (push `(bmacs--keybind-register ,(key-description (eval key))
                                              ,desc ',modes)
                      forms))
              (cond ((and bmacs--local bmacs--keymaps)
                     (push `(lwarn 'bmacs-map :warning
                                   "Can't local bind '%s' key to a keymap; skipped"
                                   ,key)
                           forms)
                     (throw 'skip 'local))
                    ((and bmacs--keymaps states)
                     (dolist (keymap bmacs--keymaps)
                       (push `(,(if bmacs--defer 'evil-define-key 'evil-define-key*)
                               ',states ,keymap ,key ,def)
                             forms)))
                    (states
                     (dolist (state states)
                       (push `(define-key
                                ,(intern (format "evil-%s-state-%smap" state (if bmacs--local "local-" "")))
                                ,key ,def)
                             forms)))
                    (bmacs--keymaps
                     (dolist (keymap bmacs--keymaps)
                       (push `(define-key ,keymap ,key ,def) forms)))
                    (t
                     (push `(,(if bmacs--local 'local-set-key 'global-set-key) ,key ,def)
                           forms))))
          (setq states '()
                bmacs--local nil
                desc nil)))

       (t (user-error "Invalid key %s" key))))
    `(progn ,@(nreverse forms)))))
#+END_SRC

*** add-hook!
A macro that makes adding hooks easy

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun bmacs--resolve-hook-forms (hooks)
    (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
             for hook in (bmacs-enlist (doom-unquote hooks))
             if (eq (car-safe hook) 'quote)
              collect (cadr hook)
             else if quoted-p
              collect hook
             else collect (intern (format "%s-hook" (symbol-name hook)))))

  (defvar bmacs--transient-counter 0)
  (defmacro add-transient-hook! (hook &rest forms)
    "Attaches transient forms to a HOOK.

  HOOK can be a quoted hook or a sharp-quoted function (which will be advised).

  These forms will be evaluated once when that function/hook is first invoked,
  then it detaches itself."
    (declare (indent 1))
    (let ((append (eq (car forms) :after))
          (fn (intern (format "bmacs-transient-hook-%s" (cl-incf bmacs--transient-counter)))))
      `(when ,hook
         (fset ',fn
               (lambda (&rest _)
                 ,@forms
                 (cond ((functionp ,hook) (advice-remove ,hook #',fn))
                       ((symbolp ,hook)   (remove-hook ,hook #',fn)))
                 (unintern ',fn nil)))
         (cond ((functionp ,hook)
                (advice-add ,hook ,(if append :after :before) #',fn))
               ((symbolp ,hook)
                (add-hook ,hook #',fn ,append)))))))

(defmacro add-hook! (&rest args)
  "A convenience macro for `add-hook'. Takes, in order:

  1. Optional properties :local and/or :append, which will make the hook
     buffer-local or append to the list of hooks (respectively),
  2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
     a quoted hook variable or a quoted list of hook variables. If unquoted, the
     hooks will be resolved by appending -hook to each symbol.
  3. A function, list of functions, or body forms to be wrapped in a lambda.

Examples:
    (add-hook! 'some-mode-hook 'enable-something)
    (add-hook! some-mode '(enable-something and-another))
    (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
    (add-hook! (one-mode second-mode) 'enable-something)
    (add-hook! :append (one-mode second-mode) 'enable-something)
    (add-hook! :local (one-mode second-mode) 'enable-something)
    (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
    (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

Body forms can access the hook's arguments through the let-bound variable
`args'."
  (declare (indent defun) (debug t))
  (let ((hook-fn 'add-hook)
        append-p local-p)
    (while (keywordp (car args))
      (pcase (pop args)
        (:append (setq append-p t))
        (:local  (setq local-p t))
        (:remove (setq hook-fn 'remove-hook))))
    (let ((hooks (bmacs--resolve-hook-forms (pop args)))
          (funcs
           (let ((val (car args)))
             (if (memq (car-safe val) '(quote function))
                 (if (cdr-safe (cadr val))
                     (cadr val)
                   (list (cadr val)))
               (list args))))
          forms)
      (dolist (fn funcs)
        (setq fn (if (symbolp fn)
                     `(function ,fn)
                   `(lambda (&rest _) ,@args)))
        (dolist (hook hooks)
          (push (cond ((eq hook-fn 'remove-hook)
                       `(remove-hook ',hook ,fn ,local-p))
                      (t
                       `(add-hook ',hook ,fn ,append-p ,local-p)))
                forms)))
      `(progn ,@(nreverse forms)))))

(defmacro remove-hook! (&rest args)
  "Convenience macro for `remove-hook'. Takes the same arguments as
`add-hook!'."
  `(add-hook! :remove ,@args))
#+END_SRC

*** quiet!
A simple macro that prevents code from making any noise

#+BEGIN_SRC emacs-lisp
(defmacro quiet! (&rest forms)
  "Run FORMS without making any noise."
  `(if nil
       (progn ,@forms)
     (fset 'doom--old-write-region-fn (symbol-function 'write-region))
     (cl-letf ((standard-output (lambda (&rest _)))
               ((symbol-function 'load-file) (lambda (file) (load file nil t)))
               ((symbol-function 'message) (lambda (&rest _)))
               ((symbol-function 'write-region)
                (lambda (start end filename &optional append visit lockname mustbenew)
                  (unless visit (setq visit 'no-message))
                  (doom--old-write-region-fn
                   start end filename append visit lockname mustbenew)))
               (inhibit-message t)
               (save-silently t))
       ,@forms)))
#+END_SRC

*** def-memoized!
Creates a memoized function

#+BEGIN_SRC emacs-lisp
(defvar doom-memoized-table (make-hash-table :test 'equal :size 10)
  "A lookup table containing memoized functions. The keys are argument lists,
and the value is the function's return value.")

(defun doom-memoize (name)
  "Memoizes an existing function. NAME is a symbol."
  (let ((func (symbol-function name)))
    (put name 'function-documentation
         (concat (documentation func) " (memoized)"))
    (fset name
          `(lambda (&rest args)
             (let ((key (cons ',name args)))
               (or (gethash key doom-memoized-table)
                   (puthash key (apply ',func args)
                            doom-memoized-table)))))))

(defmacro def-memoized! (name arglist &rest body)
  "Create a memoize'd function. NAME, ARGLIST, DOCSTRING and BODY
have the same meaning as in `defun'."
  (declare (indent defun) (doc-string 3))
  `(,(if (bound-and-true-p byte-compile-current-file)
         'with-no-warnings
       'progn)
     (defun ,name ,arglist ,@body)
     (doom-memoize ',name)))


#+END_SRC

** General Configuration

*** Core

**** Charset

Set UTF-8 as the default coding system

#+BEGIN_SRC emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
(prefer-coding-system        'utf-8)
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-selection-coding-system 'utf-8)
(setq locale-coding-system   'utf-8)
(setq-default buffer-file-coding-system 'utf-8)

#+END_SRC

**** Random Doom! Configurations

TODO - Sort these out better

#+BEGIN_SRC emacs-lisp
(setq-default
 ad-redefinition-action 'accept   ; silence advised function warnings
 apropos-do-all t                 ; make `apropos' more useful
 compilation-always-kill t        ; kill compilation process before starting another
 compilation-ask-about-save nil   ; save all buffers on `compile'
 compilation-scroll-output t
 confirm-nonexistent-file-or-buffer t
 enable-recursive-minibuffers nil
 idle-update-delay 2              ; update ui less often
 ;; keep the point out of the minibuffer
 minibuffer-prompt-properties '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)
 ;; History & backup settings (save nothing, that's what git is for)
 ;; files
 abbrev-file-name             (concat bmacs-local-dir "abbrev.el")
 auto-save-list-file-name     (concat bmacs-cache-dir "autosave"))
#+END_SRC

*** Libraries

#+BEGIN_SRC emacs-lisp
(use-package async :demand t)
(use-package s :demand t)
(use-package f :demand t)
(use-package subr-x :demand t :ensure nil)

#+END_SRC

*** Backups

We don't make any backups of files. This is what git is for.

#+BEGIN_SRC emacs-lisp
(setq-default auto-save-default nil
              create-lockfiles nil
              make-backup-files nil)
#+END_SRC

*** History

From http://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html:
#+BEGIN_SRC emacs-lisp
(setq savehist-file (concat bmacs-cache-dir "savehist")
      history-length 500
      savehist-save-minibuffer-history t
      savehist-autosave-interval nil ; save on kill only
      savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
      save-place-file (concat bmacs-cache-dir "saveplace"))

(savehist-mode +1)
(save-place-mode +1)
#+END_SRC

**** TODO Verify all the save/history settings

*** Cool doom exit messages

#+BEGIN_SRC emacs-lisp
(defun doom-quit-p (&optional prompt)
  "Return t if this session should be killed. Prompts the user for
confirmation."
(or (yes-or-no-p (format "››› %s" (or prompt "Quit Emacs?")))
    (ignore (message "Aborted"))))
(setq confirm-kill-emacs nil)
(add-hook 'kill-emacs-query-functions #'doom-quit-p)
#+END_SRC

*** UI

#+BEGIN_SRC emacs-lisp

(tooltip-mode -1) ; relegate tooltips to echo area only
(menu-bar-mode -1)
(if (fboundp 'tool-bar-mode)   (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

(setq-default
  bidi-display-reordering nil ; disable bidirectional text for tiny performance boost
  blink-matching-paren nil    ; don't blink--too distracting
  cursor-in-non-selected-windows nil  ; hide cursors in other windows
  display-line-numbers-width 3
  frame-inhibit-implied-resize t
  ;; remove continuation arrow on right fringe
  fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist)
                               fringe-indicator-alist)
  highlight-nonselected-windows nil
  image-animate-loop t
  indicate-buffer-boundaries nil
  indicate-empty-lines nil
  max-mini-window-height 0.3
  mode-line-default-help-echo nil ; disable mode-line mouseovers
  mouse-yank-at-point t           ; middle-click paste at point, not at click
  resize-mini-windows 'grow-only  ; Minibuffer resizing
  show-help-function nil          ; hide :help-echo text
  split-width-threshold 160       ; favor horizontal splits
  uniquify-buffer-name-style 'forward
  use-dialog-box nil              ; always avoid GUI
  visible-cursor nil
  x-stretch-cursor nil
  ;; defer jit font locking slightly to [try to] improve Emacs performance
  jit-lock-defer-time nil
  ;; BMACS - improve cpu usage
  jit-lock-stealth-nice 0.5
  jit-lock-stealth-time 1
  jit-lock-stealth-verbose nil
  ;; `pos-tip' defaults
  pos-tip-internal-border-width 6
  pos-tip-border-width 1
  ;; no beeping or blinking please
  ring-bell-function #'ignore
  visible-bell nil)

  (fset #'yes-or-no-p #'y-or-n-p) ; y/n instead of yes/no
#+END_SRC

**** TODO Break this apart with comments

**** Line numbers
Enable line numbers

#+BEGIN_SRC emacs-lisp
(defun bmacs|enable-line-numbers (&optional arg)
  "Enables the display of line numbers, using `display-line-numbers' (in Emacs
26+) or `nlinum-mode'."
  (if (boundp 'display-line-numbers)
      (setq display-line-numbers t)
    (nlinum-mode +1)))

(defun bmacs|disable-line-numbers ()
  "Disable the display of line numbers."
  (if (boundp 'display-line-numbers)
      (setq display-line-numbers nil)
    (nlinum-mode -1)))

(add-hook 'prog-mode-hook #'bmacs|enable-line-numbers)
(add-hook 'text-mode-hook #'bmacs|enable-line-numbers)
(add-hook 'conf-mode-hook #'bmacs|enable-line-numbers)
#+END_SRC

*** Editor

#+BEGIN_SRC emacs-lisp
(setq-default
 vc-follow-symlinks t
 ;; Save clipboard contents into kill-ring before replacing them
 save-interprogram-paste-before-kill t
 ;; Bookmarks
 bookmark-default-file (concat bmacs-cache-dir "bookmarks")
 bookmark-save-flag t
 ;; Formatting
 delete-trailing-lines nil
 fill-column 100
 sentence-end-double-space nil
 word-wrap t
 ;; Scrolling
 hscroll-margin 1
 hscroll-step 1
 scroll-conservatively 1001
 scroll-margin 0
 scroll-preserve-screen-position t
 ;; Whitespace
 indent-tabs-mode nil
 require-final-newline t
 tab-always-indent t
 tab-width 2
 tabify-regexp "^\t* [ \t]+" ; for :retab
 ;; Wrapping
 truncate-lines t
 truncate-partial-width-windows 50
 ;; whitespace-mode
 whitespace-line-column fill-column
 whitespace-style
 '(face indentation tabs tab-mark spaces space-mark newline newline-mark
   trailing lines-tail)
 whitespace-display-mappings
 '((tab-mark ?\t [?› ?\t])
   (newline-mark ?\n [?¬ ?\n])
   (space-mark ?\  [?·] [?.])))


;; revert buffers for changed files
(global-auto-revert-mode 1)
(setq auto-revert-verbose nil)

(show-paren-mode)
#+END_SRC

**** TODO Break apart?

**** Auto Indent Pasted Code

#+BEGIN_SRC emacs-lisp
(defvar bmacs|yank-indent-threshold 1000 "don't auto indent over 1000 lines")

(defvar bmacs|indent-sensitive-modes '(conf-mode coffee-mode haml-mode python-mode slim-mode yaml-mode)
  "modes to limit auto indentation on")


(defmacro bmacs|advise-commands (advice-name commands class &rest body)
  "Apply advice named ADVICE-NAME to multiple COMMANDS.
  The body of the advice is in BODY."
  `(progn
     ,@(mapcar (lambda (command)
                 `(defadvice ,command
                      (,class ,(intern (format "%S-%s" command advice-name))
                              activate)
                    ,@body))
               commands)))

(defvar bmacs-indent-sensitive-modes '(conf-mode coffee-mode haml-mode python-mode slim-mode yaml-mode)
  "modes to limit auto indentation on")

(defun bmacs|yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) bmacs|yank-indent-threshold)
      (indent-region beg end nil)))

(bmacs|advise-commands
  "indent" (evil-paste-before evil-paste-after) around
  "If current mode is not one of bmacs-indent-sensitive-modes
  indent yanked text (with universal arg don't indent)."
  ad-do-it
  (evil-with-single-undo
    (if (and (not (equal '(4) (ad-get-arg 0)))
             (not (member major-mode bmacs-indent-sensitive-modes)) ;; TODO indent-sensitive-modes
             (derived-mode-p 'prog-mode))
        (let ((transient-mark-mode nil)
              (save-undo buffer-undo-list))
          (bmacs|yank-advised-indent-function (region-beginning)
                                                (region-end))))))
#+END_SRC

*** Font

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font (font-spec :family "Iosevka" :size 25))
#+END_SRC


*** Operating System Specific

#+BEGIN_SRC emacs-lisp
(setq IS-LINUX (eq system-type 'gnu/linux)
      IS-MAC (eq system-type 'darwin))
#+END_SRC


**** Clipboard
Use shared system clipboard and don't stream visual changes to clipboard

#+BEGIN_SRC emacs-lisp
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
      select-enable-clipboard t
      select-enable-primary t)

(after! evil
  (advice-add #'evil-visual-update-x-selection :override #'ignore))
#+END_SRC

**** Linux

#+BEGIN_SRC emacs-lisp
(if IS-LINUX
  (setq x-gtk-use-system-tooltips nil))
#+END_SRC

**** Mac

#+BEGIN_SRC emacs-lisp
(if IS-MAC
  (setq mac-command-modifier 'meta
        mac-option-modifier  'alt
        ;; sane trackpad/mouse scroll settings
        mac-redisplay-dont-reset-vscroll t
        mac-mouse-wheel-smooth-scroll nil
        mouse-wheel-scroll-amount '(5 ((shift) . 2))  ; one line at a time
        mouse-wheel-progressive-speed nil             ; don't accelerate scrolling
        ;; Curse Lion and its sudden but inevitable fullscreen mode!
        ;; NOTE Meaningless to railwaycat's emacs-mac build
        ns-use-native-fullscreen nil
        ;; Don't open files from the workspace in a new frame
        ns-pop-up-frames nil)

  (cond ((display-graphic-p)
         ;; A known problem with GUI Emacs on MacOS: it runs in an isolated
         ;; environment, so envvars will be wrong. That includes the PATH
         ;; Emacs picks up. `exec-path-from-shell' fixes this. This is slow
         ;; and benefits greatly from compilation.
         (setq exec-path
               (or (eval-when-compile
                     (when (require 'exec-path-from-shell nil t)
                       (setq exec-path-from-shell-check-startup-files nil
                             exec-path-from-shell-arguments (delete "-i" exec-path-from-shell-arguments))
                       (nconc exec-path-from-shell-variables '("GOPATH" "GOROOT" "PYTHONPATH"))
                       (exec-path-from-shell-initialize)
                       exec-path))
                   exec-path)))
        (t
         (when (require 'osx-clipboard nil t)
           (osx-clipboard-mode +1)))))
#+END_SRC

** Core Packages

*** which-key
Dynamically show keybinding options.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :demand t
  :config
  (setq which-key-sort-order #'which-key-prefix-then-key-order
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 5)
  ;; embolden local bindings
  (set-face-attribute 'which-key-local-map-description-face nil :weight 'bold)
  (which-key-setup-side-window-bottom)
  (which-key-mode))
#+END_SRC

*** smartparens
Auto-close delimiters and blocks as you type.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :demand t
  :config
  (setq sp-autowrap-region nil ; let evil-surround handle this
        sp-highlight-pair-overlay nil
        sp-cancel-autoskip-on-backward-movement nil
        sp-show-pair-delay 0
        sp-max-pair-length 3)

  (require 'smartparens-config)

  ;; disable smartparens in evil-mode's replace state (they conflict)
  (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
  (add-hook 'evil-replace-state-exit-hook  #'turn-on-smartparens-mode)

  (sp-local-pair '(xml-mode nxml-mode php-mode) "<!--" "-->"
                 :post-handlers '(("| " "SPC")))

  ;; Auto-close more conservatively
  (let ((unless-list '(sp-point-before-word-p
                       sp-point-after-word-p
                       sp-point-before-same-p)))
    (sp-pair "'"  nil :unless unless-list)
    (sp-pair "\"" nil :unless unless-list))
  (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET") ("| " " "))
           :unless '(sp-point-before-word-p sp-point-before-same-p))
  (sp-pair "(" nil :post-handlers '(("||\n[i]" "RET") ("| " " "))
           :unless '(sp-point-before-word-p sp-point-before-same-p))
  (sp-pair "[" nil :post-handlers '(("| " " "))
           :unless '(sp-point-before-word-p sp-point-before-same-p))

  (smartparens-global-mode))
#+END_SRC

*** Ivy
They power and the glory! Generic complete anything frontend

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :demand t
  :init
  (add-hook 'bmacs-post-init-hook #'ivy-mode)
  :config
  (setq ivy-height 12
        ivy-wrap t
        ivy-fixed-height-minibuffer t
        projectile-completion-system 'ivy
        smex-completion-method 'ivy
        ;; Don't use ^ as initial input
        ivy-initial-inputs-alist nil
        ;; highlight til EOL
        ivy-format-function #'ivy-format-function-line
        ;; disable magic slash on non-match
        ivy-magic-slash-non-match-action nil
        ;; BMACS allow input prompt value to be selectable
        ivy-use-selectable-prompt t)

  (after! magit     (setq magit-completing-read-function #'ivy-completing-read))
  (after! yasnippet (push #'+ivy-yas-prompt yas-prompt-functions))

  (map! :map ivy-mode-map
        [remap apropos]                   #'counsel-apropos
        [remap describe-face]             #'counsel-describe-face
        [remap find-file]                 #'counsel-find-file
        [remap switch-to-buffer]          #'ivy-switch-buffer
        ;[remap persp-switch-to-buffer]    #'+ivy/switch-workspace-buffer TODO
        [remap recentf-open-files]        #'counsel-recentf
        [remap imenu]                     #'counsel-imenu
        [remap bookmark-jump]             #'counsel-bookmark
        [remap projectile-switch-project] #'counsel-projectile-switch-project
        [remap projectile-find-file]      #'counsel-projectile-find-file
        [remap imenu-anywhere]            #'ivy-imenu-anywhere
        [remap execute-extended-command]  #'counsel-M-x
        [remap describe-function]         #'counsel-describe-function
        [remap describe-variable]         #'counsel-describe-variable
        [remap describe-face]             #'counsel-describe-face)

  (defsubst +ivy--icon-for-mode (mode)
    "Apply `all-the-icons-for-mode' on MODE but either return an icon or nil."
    (let ((icon (all-the-icons-icon-for-mode mode)))
      (unless (symbolp icon) icon)))

  (defun +ivy-buffer-transformer (str)
    (let* ((buf (get-buffer str))
           (path (buffer-file-name buf))
           (mode (buffer-local-value 'major-mode buf))
           (faces
            (with-current-buffer buf
              (cond ((string-match-p "^ ?\\*" (buffer-name buf))
                     'font-lock-comment-face)
                    ((buffer-modified-p buf)
                     'doom-modeline-buffer-modified) ;; TODO ?
                    (buffer-read-only
                     'error)))))
      (propertize
       (format "%-40s %s%-20s %s"
               str
                   (concat (propertize " " 'display
                                       (or (+ivy--icon-for-mode mode)
                                           (+ivy--icon-for-mode (get mode 'derived-mode-parent))))
                           "\t")
               mode
               (or (and path (abbreviate-file-name (file-name-directory (file-truename path))))
                   ""))
       'face faces)))

  ;; Show more buffer information in switch-buffer commands
  (ivy-set-display-transformer #'ivy-switch-buffer #'+ivy-buffer-transformer)
  (ivy-set-display-transformer #'ivy-switch-buffer-other-window #'+ivy-buffer-transformer)
  (ivy-set-display-transformer #'+ivy/switch-workspace-buffer #'+ivy-buffer-transformer)
  (ivy-set-display-transformer #'counsel-recentf #'abbreviate-file-name)

  ;; Don't sort perp mode related lists
  (nconc ivy-sort-functions-alist
         '((persp-kill-buffer   . nil)
           (persp-remove-buffer . nil)
           (persp-add-buffer    . nil)
           (persp-switch        . nil)
           (persp-window-switch . nil)
           (persp-frame-switch  . nil))))
#+END_SRC

*** evil
Like vim but better.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :demand t
  :init
  (setq evil-want-C-u-scroll t
        evil-want-visual-char-semi-exclusive t
        evil-want-Y-yank-to-eol t
        evil-magic t
        evil-echo-state t
        evil-indent-convert-tabs t
        evil-ex-search-vim-style-regexp t
        evil-ex-substitute-global t
        evil-ex-visual-char-range t  ; column range for ex commands
        evil-insert-skip-empty-lines t
        evil-mode-line-format 'nil
        ;; more vim-like behavior
        evil-symbol-word-search t
        ;; don't activate mark on shift-click
        shift-select-mode nil)

  :config
  (evil-select-search-module 'evil-search-module 'evil-search)

  ;; Set cursor colors later, once theme is loaded
  (defun +evil*init-cursors (&rest _)
    (setq evil-default-cursor (face-background 'cursor nil t)
          evil-normal-state-cursor 'box
          evil-emacs-state-cursor  `(,(face-foreground 'warning) box)
          evil-insert-state-cursor 'bar
          evil-visual-state-cursor 'hollow))
  (advice-add #'load-theme :after #'+evil*init-cursors)

  ;; default modes
  (dolist (mode '(tabulated-list-mode view-mode comint-mode term-mode calendar-mode Man-mode grep-mode))
    (evil-set-initial-state mode 'emacs))
  (dolist (mode '(help-mode debugger-mode))
    (evil-set-initial-state mode 'normal))

  ;; make `try-expand-dabbrev' from `hippie-expand' work in minibuffer
  ;; @see `he-dabbrev-beg', so we need re-define syntax for '/'
  (defun minibuffer-inactive-mode-hook-setup ()
    (set-syntax-table (let* ((table (make-syntax-table)))
                        (modify-syntax-entry ?/ "." table)
                        table)))
  (add-hook 'minibuffer-inactive-mode-hook #'minibuffer-inactive-mode-hook-setup)

  ;; --- evil hacks -------------------------
  (defvar +evil-esc-hook '(t)
    "A hook run after ESC is pressed in normal mode (invoked by
`evil-force-normal-state'). If any hook returns non-nil, all hooks after it are
ignored.")

  (defun +evil*attach-escape-hook ()
    "Run the `+evil-esc-hook'."
    (cond ((minibuffer-window-active-p (minibuffer-window))
           ;; quit the minibuffer if open.
           (abort-recursive-edit))
          ((evil-ex-hl-active-p 'evil-ex-search)
           ;; disable ex search buffer highlights.
           (evil-ex-nohighlight))
          (t
           ;; Run all escape hooks. If any returns non-nil, then stop there.
           (run-hook-with-args-until-success '+evil-esc-hook))))
  (advice-add #'evil-force-normal-state :after #'+evil*attach-escape-hook)

  (defun +evil*restore-normal-state-on-windmove (orig-fn &rest args)
    "If in anything but normal or motion mode when moving to another window,
restore normal mode. This prevents insert state from bleeding into other modes
across windows."
    (unless (memq evil-state '(normal motion emacs))
      (evil-normal-state +1))
    (apply orig-fn args))
  (advice-add #'windmove-do-window-select :around #'+evil*restore-normal-state-on-windmove)


  (defvar +evil--flag nil)

  (defun +evil--ex-match-init (name &optional face update-hook)
    (with-current-buffer evil-ex-current-buffer
      (cond
       ((eq +evil--flag 'start)
        (evil-ex-make-hl name
          :face (or face 'evil-ex-substitute-matches)
          :update-hook (or update-hook #'evil-ex-pattern-update-ex-info))
        (setq +evil--flag 'update))

       ((eq +evil--flag 'stop)
        (evil-ex-delete-hl name)))))

  (defun +evil--ex-buffer-match (arg &optional hl-name flags beg end)
    (when (and (eq +evil--flag 'update)
               evil-ex-substitute-highlight-all
               (not (zerop (length arg))))
      (condition-case lossage
          (let ((pattern (evil-ex-make-substitute-pattern
                          (if evil-ex-bang (regexp-quote arg) arg)
                          (or flags (list))))
                (range (or (evil-copy-range evil-ex-range)
                           (evil-range (or beg (line-beginning-position))
                                       (or end (line-end-position))
                                       'line
                                       :expanded t))))
            (evil-expand-range range)
            (evil-ex-hl-set-region hl-name
                                   (max (evil-range-beginning range) (window-start))
                                   (min (evil-range-end range) (window-end)))
            (evil-ex-hl-change hl-name pattern))
        (end-of-file
         (evil-ex-pattern-update-ex-info nil "incomplete replacement"))
        (user-error
         (evil-ex-pattern-update-ex-info nil (format "?%s" lossage))))))

  (defun +evil-ex-buffer-match (flag &optional arg)
    (let ((hl-name 'evil-ex-buffer-match)
          (+evil--flag flag))
      (with-selected-window (minibuffer-selected-window)
        (+evil--ex-match-init hl-name)
        (+evil--ex-buffer-match arg hl-name (list (if evil-ex-substitute-global ?g))))))

  (defun +evil-ex-global-match (flag &optional arg)
    (let ((hl-name 'evil-ex-global-match)
          (+evil--flag flag))
      (with-selected-window (minibuffer-selected-window)
        (+evil--ex-match-init hl-name)
        (+evil--ex-buffer-match arg hl-name nil (point-min) (point-max)))))

  ;; These arg types will highlight matches in the current buffer
  (evil-ex-define-argument-type buffer-match :runner +evil-ex-buffer-match)
  (evil-ex-define-argument-type global-match :runner +evil-ex-global-match)


  (defun +evil-ex-global-delim-match (flag &optional arg)
    (let ((hl-name 'evil-ex-global-delim-match)
          (+evil--flag flag))
      (with-selected-window (minibuffer-selected-window)
        (+evil--ex-match-init hl-name)
        (let ((result (car-safe (evil-delimited-arguments arg 2))))
          (+evil--ex-buffer-match result hl-name nil (point-min) (point-max))))))

  ;; By default :g[lobal] doesn't highlight matches in the current buffer. I've
  ;; got to write my own argument type and interactive code to get it to do so.
  (evil-ex-define-argument-type global-delim-match :runner +evil-ex-global-delim-match)

  (dolist (sym '(evil-ex-global evil-ex-global-inverted))
    (evil-set-command-property sym :ex-arg 'global-delim-match))

  ;; Move to new split -- setting `evil-split-window-below' &
  ;; `evil-vsplit-window-right' to non-nil mimics this, but that doesn't update
  ;; window history. That means when you delete a new split, Emacs leaves you on
  ;; the 2nd to last window on the history stack, which is jarring.
  (defun +evil*window-follow (&rest _)  (evil-window-down 1))
  (defun +ertmp://rtmp.stream.live:1935/live/9da5fd3f-239b-4a20-b795-e977e39ba752vil*window-vfollow (&rest _) (evil-window-right 1))
  (advice-add #'evil-window-split  :after #'+evil*window-follow)
  (advice-add #'evil-window-vsplit :after #'+evil*window-vfollow)

  (evil-mode))
#+END_SRC

I like to prevent evil from yanking text to the clipboard in many scenarios.

#+BEGIN_SRC emacs-lisp
(evil-define-operator evil-delete-char-without-register (beg end type reg)
  "delete character without yanking unless in visual mode"
  :motion evil-forward-char
  (interactive "<R><y>")
  (if (evil-visual-state-p)
    (evil-delete beg end type reg)
    (evil-delete beg end type ?_)))

;;;###autoload (autoload 'evil-delete-backward-char-without-register "feature/evil/autoload/evil" nil t)
(evil-define-operator evil-delete-backward-char-without-register (beg end type _)
  "delete backward character without yanking"
  :motion evil-backward-char
  (interactive "<R><y>")
  (evil-delete beg end type ?_))

;;;###autoload (autoload 'evil-delete-without-register "feature/evil/autoload/evil" nil t)
(evil-define-operator evil-delete-without-register (beg end type _ _)
  (interactive "<R><y>")
  (evil-delete beg end type ?_))

;;;###autoload (autoload 'evil-delete-without-register-if-whitespace "feature/evil/autoload/evil" nil t)
(evil-define-operator evil-delete-without-register-if-whitespace (beg end type reg yank-handler)
  (interactive "<R><y>")
  (let ((text (replace-regexp-in-string "\n" "" (filter-buffer-substring beg end))))
    (if (string-match-p "^\\s-*$" text)
      (evil-delete beg end type ?_)
      (evil-delete beg end type reg yank-handler))))

;;;###autoload (autoload 'evil-delete-line-without-register "feature/evil/autoload/evil" nil t)
(evil-define-operator evil-delete-line-without-register (beg end type _ yank-handler)
    (interactive "<R><y>")
    (evil-delete-line beg end type ?_ yank-handler))

;;;###autoload (autoload 'evil-change-without-register "feature/evil/autoload/evil" nil t)
(evil-define-operator evil-change-without-register (beg end type _ yank-handler)
  (interactive "<R><y>")
  (evil-change beg end type ?_ yank-handler))

;;;###autoload (autoload 'evil-change-line-without-register "feature/evil/autoload/evil" nil t)
(evil-define-operator evil-change-line-without-register (beg end type _ yank-handler)
  "Change to end of line without yanking."
  :motion evil-end-of-line
  (interactive "<R><y>")
  (evil-change beg end type ?_ yank-handler #'evil-delete-line))

;;;###autoload (autoload 'evil-paste-after-without-register "feature/evil/autoload/evil" nil t)
(evil-define-command evil-paste-after-without-register (count &optional register yank-handler)
  "evil paste before without yanking"
  :suppress-operator t
  (interactive "P<x>")
  (if (evil-visual-state-p)
      (evil-visual-paste-without-register count register)
      (evil-paste-after count register yank-handler)))

;;;###autoload (autoload 'evil-paste-before-without-register "feature/evil/autoload/evil" nil t)
(evil-define-command evil-paste-before-without-register (count &optional register yank-handler)
  "evil paste before without yanking"
  :suppress-operator t
  (interactive "P<x>")
  (if (evil-visual-state-p)
      (evil-visual-paste-without-register count register)
      (evil-paste-before count register yank-handler)))

;;;###autoload (autoload 'evil-visual-paste-without-register "feature/evil/autoload/evil" nil t)
(evil-define-command evil-visual-paste-without-register (count &optional register)
  "Paste over Visual selection."
  :suppress-operator t
  (interactive "P<x>")
  ;; evil-visual-paste is typically called from evil-paste-before or
  ;; evil-paste-after, but we have to mark that the paste was from
  ;; visual state
  (setq this-command 'evil-visual-paste)
  (let* ((text (if register
                   (evil-get-register register)
                 (current-kill 0)))
         (yank-handler (car-safe (get-text-property
                                  0 'yank-handler text)))
         new-kill
         paste-eob)
    (evil-with-undo
      (let* ((kill-ring (list (current-kill 0)))
             (kill-ring-yank-pointer kill-ring))
        (when (evil-visual-state-p)
          (evil-visual-rotate 'upper-left)
          ;; if we replace the last buffer line that does not end in a
          ;; newline, we use `evil-paste-after' because `evil-delete'
          ;; will move point to the line above
          (when (and (= evil-visual-end (point-max))
                     (/= (char-before (point-max)) ?\n))
            (setq paste-eob t))
          (evil-delete-without-register evil-visual-beginning evil-visual-end
                       (evil-visual-type))
          (when (and (eq yank-handler #'evil-yank-line-handler)
                     (not (eq (evil-visual-type) 'line))
                     (not (= evil-visual-end (point-max))))
            (insert "\n"))
          (evil-normal-state)
          (setq new-kill (current-kill 0))
          (current-kill 1))
        (if paste-eob
            (evil-paste-after count register)
          (evil-paste-before count register)))
      (kill-new new-kill)
      ;; mark the last paste as visual-paste
      (setq evil-last-paste
            (list (nth 0 evil-last-paste)
                  (nth 1 evil-last-paste)
                  (nth 2 evil-last-paste)
                  (nth 3 evil-last-paste)
                  (nth 4 evil-last-paste)
                  t)))))
#+END_SRC

** Completion

*** Swiper
Awesome visual search utility

#+BEGIN_SRC emacs-lisp
(use-package swiper :commands (swiper swiper-all))
#+END_SRC

*** Counsel
Making everything all ivy-ed up.

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile :demand t)
(use-package counsel
  :demand t
  :config
  (require 'counsel-projectile)
  (setq counsel-find-file-ignore-regexp "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)")

  ;; Configure `counsel-rg', `counsel-ag' & `counsel-pt'
  ;(set! :popup 'ivy-occur-grep-mode :size (+ 2 ivy-height) :regexp t :autokill t) TODO
  (dolist (cmd '(counsel-ag counsel-rg counsel-pt))
    (ivy-add-actions
     cmd
     '(("O" +ivy-git-grep-other-window-action "open in other window"))))

  ;; 1. Remove character limit from `counsel-ag-function'
  ;; 2. Disable ivy's over-zealous parentheses quoting behavior (if i want
  ;;    literal parentheses, I'll escape them myself).
  ;; 3. This may need to be updated frequently, to meet changes upstream
  ;; 4. counsel-ag, counsel-rg and counsel-pt all use this function
  (defun +ivy*counsel-ag-function (string base-cmd extra-ag-args)
    "Advice to 1) get rid of the character limit from `counsel-ag-function' and 2)
  disable ivy's over-zealous parentheses quoting behavior (if i want literal
  parentheses, I'll escape them myself).

  NOTE This may need to be updated frequently, to meet changes upstream (in
  counsel-rg)."
    (when (null extra-ag-args)
      (setq extra-ag-args ""))
    (if (< (length string) 1)  ;; #1
        (counsel-more-chars 1)
      (let ((default-directory counsel--git-dir)
            (regex (counsel-unquote-regex-parens
                    (setq ivy--old-re
                          (ivy--regex
                           (counsel-unquote-regex-parens string)))))) ;; #2
        (let* ((args-end (string-match " -- " extra-ag-args))
               (file (if args-end
                         (substring-no-properties extra-ag-args (+ args-end 3))
                       ""))
               (extra-ag-args (if args-end
                                  (substring-no-properties extra-ag-args 0 args-end)
                                extra-ag-args))
               (ag-cmd (format base-cmd
                               (concat extra-ag-args
                                       " -- "
                                       (shell-quote-argument regex)
                                       file))))
          (if (file-remote-p default-directory)
              (split-string (shell-command-to-string ag-cmd) "\n" t)
            (counsel--async-command ag-cmd)
            nil)))))
  (advice-add #'counsel-ag-function :override #'+ivy*counsel-ag-function))
#+END_SRC

*** smex
Improved M-x

#+BEGIN_SRC emacs-lisp
(use-package smex
  :commands (smex smex-major-mode-commands)
  :config
  (setq smex-save-file (concat bmacs-cache-dir "/smex-items"))
  (smex-initialize))
#+END_SRC


*** ivy-hydra
Nice ivy hydra

#+BEGIN_SRC emacs-lisp
(use-package ivy-hydra
  :after ivy
  :commands (+ivy@coo/body ivy-dispatching-done-hydra)
  :init
  ; (map! :map ivy-minibuffer-map
  ;       "C-o" #'+ivy@coo/body
  ;       "M-o" #'ivy-dispatching-done-hydra) TODO
  :config
  (defhydra +ivy@coo (:hint nil :color pink)
    "
 Move     ^^^^^^^^^^ | Call         ^^^^ | Cancel^^ | Options^^ | Action _w_/_s_/_a_: %s(ivy-action-name)
----------^^^^^^^^^^-+--------------^^^^-+-------^^-+--------^^-+---------------------------------
 _g_ ^ ^ _k_ ^ ^ _u_ | _f_orward _o_ccur | _i_nsert | _c_alling: %-7s(if ivy-calling \"on\" \"off\") _C_ase-fold: %-10`ivy-case-fold-search
 ^↨^ _h_ ^+^ _l_ ^↕^ | _RET_ done     ^^ | _q_uit   | _m_atcher: %-7s(ivy--matcher-desc) _t_runcate: %-11`truncate-lines
 _G_ ^ ^ _j_ ^ ^ _d_ | _TAB_ alt-done ^^ | ^ ^      | _<_/_>_: shrink/grow
"
    ;; arrows
    ("j" ivy-next-line)
    ("k" ivy-previous-line)
    ("l" ivy-alt-done)
    ("h" ivy-backward-delete-char)
    ("g" ivy-beginning-of-buffer)
    ("G" ivy-end-of-buffer)
    ("d" ivy-scroll-up-command)
    ("u" ivy-scroll-down-command)
    ("e" ivy-scroll-down-command)
    ;; actions
    ("q" keyboard-escape-quit :exit t)
    ("C-g" keyboard-escape-quit :exit t)
    ("<escape>" keyboard-escape-quit :exit t)
    ("C-o" nil)
    ("i" nil)
    ("TAB" ivy-alt-done :exit nil)
    ("C-j" ivy-alt-done :exit nil)
    ;; ("d" ivy-done :exit t)
    ("RET" ivy-done :exit t)
    ("C-m" ivy-done :exit t)
    ("f" ivy-call)
    ("c" ivy-toggle-calling)
    ("m" ivy-toggle-fuzzy)
    (">" ivy-minibuffer-grow)
    ("<" ivy-minibuffer-shrink)
    ("w" ivy-prev-action)
    ("s" ivy-next-action)
    ("a" ivy-read-action)
    ("t" (setq truncate-lines (not truncate-lines)))
    ("C" ivy-toggle-case-fold)
    ("o" ivy-occur :exit t)))
#+END_SRC

*** company
Generic code auto completion

#+BEGIN_SRC emacs-lisp
(use-package company
  :commands (company-mode global-company-mode company-complete
             company-complete-common company-manual-begin company-grab-line)
  :config
  (setq company-idle-delay nil
        company-tooltip-limit 10
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil
        company-dabbrev-code-other-buffers t
        company-tooltip-align-annotations t
        company-idle-delay 0.1
        company-minimum-prefix-length 3
        company-require-match 'never
        company-global-modes '(not eshell-mode comint-mode erc-mode message-mode help-mode gud-mode)
        company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)
        company-backends '(company-capf company-dabbrev-code company-keywords company-files company-dabbrev)
        company-transformers '(company-sort-by-occurrence))

  (after! yasnippet
    (nconc company-backends '(company-yasnippet)))

  (global-company-mode +1))
#+END_SRC

*** comany-statistics
Keep company completion statistics to improve sorting

#+BEGIN_SRC emacs-lisp
(use-package company-statistics
  :after company
  :config
  (setq company-statistics-file (concat bmacs-cache-dir "company-stats-cache.el"))
  (quiet! (company-statistics-mode +1)))
#+END_SRC

*** company-quickhelp
Show documentation popups for company

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :after company
  :config
  (setq company-quickhelp-delay nil)
  (company-quickhelp-mode +1))
#+END_SRC

*** company-dict - TODO - review commented out doom code
Dictionary based completions in company

#+BEGIN_SRC emacs-lisp
  (use-package company-dict
    :commands company-dict)
    ;; :config
    ;; (defun +company|enable-project-dicts (mode &rest _)
    ;;   "Enable per-project dictionaries."
    ;;   (if (symbol-value mode)
    ;;       (cl-pushnew mode company-dict-minor-mode-list :test #'eq)
    ;;     (setq company-dict-minor-mode-list (delq mode company-dict-minor-mode-list))))
    ;; (add-hook 'doom-project-hook #'+company|enable-project-dicts))
#+END_SRC

** Workspaces

*** persp-mode
Allows for creation of isolated workspaces

#+BEGIN_SRC emacs-lisp
(defvar +workspaces-last-persp nil
  "A variable that contains the last accessed perspective")

(use-package persp-mode :demand t
  :config
  (setq wg-morph-on nil
        persp-autokill-buffer-on-remove 'kill-weak
        persp-nil-name "nil"
        persp-nil-hidden t
        persp-auto-save-fname "autosave"
        persp-auto-resume-time 1
        persp-auto-save-opt 1
        persp-save-dir (concat bmacs-cache-dir "workspaces/"))

  (defun +workspaces*track-last-persp (switch-fun &rest args)
    (let ((before-persp (safe-persp-name (get-current-persp)))
          (after-persp (apply switch-fun args)))
      (when (not (string= before-persp after-persp))
        (setq +workspaces-last-persp before-persp))))

  (advice-add #'persp-switch :around #'+workspaces*track-last-persp)
  (add-hook 'bmacs-post-init-hook #'(lambda () (persp-mode 1))))

(defun +workspace-exists-p (name)
  "Returns t if NAME is the name of an existing workspace."
  (when (symbolp name)
    (setq name (symbol-name name)))
  (unless (stringp name)
    (error "Expected a string, got a %s" (type-of name)))
    (member name (persp-names-current-frame-fast-ordered)))

(defun +workspace-switch-last ()
  "Switches to the last workspace"
  (interactive)
  (if (+workspace-exists-p +workspaces-last-persp)
    (persp-switch +workspaces-last-persp)
    (error "No previous workspace.")))

(defun +workspace-switch-project (arg)
  (interactive "P")
  (ivy-read "Switch to Project Perspective: "
            (if (projectile-project-p)
                (cons (abbreviate-file-name (projectile-project-root))
                      (projectile-relevant-known-projects))
              projectile-known-projects)
            :action (lambda (project)
                      (let ((persp-reset-windows-on-nil-window-conf t))
                        (persp-switch project)
                        (let ((projectile-completion-system 'ivy))
                          (projectile-switch-project-by-name project))))))
#+END_SRC


*** TODO eyebrowse ?

** Editing

**** evil-commentary
Robust commenting support in evil-mode

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :commands (evil-commentary evil-commentary-yank evil-commentary-line)
  :config (evil-commentary-mode 1))
#+END_SRC

**** evil-easymotion
I like to move it move it

#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :after evil-snipe
  :commands evilem-create
  :config
  (let ((prefix "g"))
    (evilem-default-keybindings prefix)
    (evilem-define (kbd (concat prefix " l")) #'evil-forward-word-begin :scope 'line)
    (evilem-define (kbd (concat prefix " h")) #'evil-backward-word-begin :scope 'line)
    (evilem-define (kbd (concat prefix " L")) #'evil-forward-WORD-begin :scope 'line)
    (evilem-define (kbd (concat prefix " H")) #'evil-backward-WORD-begin :scope 'line)
    (evilem-define (kbd (concat prefix " (")) #'evil-backward-sentence-begin)
    (evilem-define (kbd (concat prefix " )")) #'evil-forward-sentence-begin)
    (evilem-define (kbd (concat prefix " n")) #'evil-ex-search-next)
    (evilem-define (kbd (concat prefix " N")) #'evil-ex-search-previous))
  (map! :nv "gg" 'evil-goto-first-line))
#+END_SRC

**** TODO evil-embrace - check this one out further

#+BEGIN_SRC emacs-lisp
(use-package evil-embrace
  :after evil-surround
  :config
  (setq evil-embrace-show-help-p nil)
  (evil-embrace-enable-evil-surround-integration)

  (defun +evil--embrace-get-pair (char)
    (if-let (pair (cdr-safe (assoc (string-to-char char) evil-surround-pairs-alist)))
        pair
      (if-let (pair (assoc-default char embrace--pairs-list))
          (if-let (real-pair (and (functionp (embrace-pair-struct-read-function pair))
                                  (funcall (embrace-pair-struct-read-function pair))))
              real-pair
            (cons (embrace-pair-struct-left pair) (embrace-pair-struct-right pair)))
        (cons char char))))

  (defun +evil--embrace-escaped ()
    "Backslash-escaped surround character support for embrace."
    (let ((char (read-char "\\")))
      (if (eq char 27)
          (cons "" "")
        (let ((pair (+evil--embrace-get-pair (string char)))
              (text (if (sp-point-in-string) "\\\\%s" "\\%s")))
          (cons (format text (car pair))
                (format text (cdr pair)))))))

  (defun +evil--embrace-latex ()
    "LaTeX command support for embrace."
    (cons (format "\\%s{" (read-string "\\")) "}"))

  (defun +evil--embrace-elisp-fn ()
    "Elisp function support for embrace."
    (cons (format "(%s " (or (read-string "(") "")) ")"))

  ;; Add escaped-sequence support to embrace
  (cl-pushnew (cons ?\\ (make-embrace-pair-struct
                         :key ?\\
                         :read-function #'+evil--embrace-escaped
                         :left-regexp "\\[[{(]"
                         :right-regexp "\\[]})]"))
              (default-value 'embrace--pairs-list)
              :key #'car)

  ;; Add extra pairs
  (add-hook 'LaTeX-mode-hook #'embrace-LaTeX-mode-hook)
  (add-hook 'org-mode-hook   #'embrace-org-mode-hook)
  (add-hook 'emacs-lisp-mode #'(lambda ()
    (embrace-add-pair ?\` "`" "'")))
  (add-hook 'emacs-lisp-mode #'(lambda ()
    (embrace-add-pair-regexp ?f "([^ ]+ " ")" #'+evil--embrace-elisp-fn)))
  (add-hook 'lisp-mode #'(lambda ()
    (embrace-add-pair-regexp ?f "([^ ]+ " ")" #'+evil--embrace-elisp-fn)))
  (add-hook 'org-mode (lambda ()
    (embrace-add-pair-regexp ?l "\\[a-z]+{" "}" #'+evil--embrace-latex)))
  (add-hook 'LaTeX-mode (lambda ()
    (embrace-add-pair-regexp ?l "\\[a-z]+{" "}" #'+evil--embrace-latex))))

#+END_SRC

**** evil-escape
Escape everything

#+BEGIN_SRC emacs-lisp
(use-package evil-escape
  :commands evil-escape-mode
  :init
  (setq evil-escape-excluded-states '(normal visual multiedit emacs motion)
        evil-escape-key-sequence nil
        evil-escape-excluded-major-modes '(neotree-mode)
        evil-escape-delay 0.25)
  (add-hook 'bmacs-post-init-hook #'evil-escape-mode)
  :config
  ;; no `evil-escape' in minibuffer
  (cl-pushnew #'minibufferp evil-escape-inhibit-functions :test #'eq)
  (map! :irvo "C-g" #'evil-escape))

#+END_SRC


**** evil-matchit
Jump between matching delimiters

#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :commands (evilmi-jump-items evilmi-text-object global-evil-matchit-mode)
  :config (global-evil-matchit-mode 1)
  :init
  (map! [remap evil-jump-item] #'evilmi-jump-items
        :textobj "%" #'evilmi-text-object #'evilmi-text-object)
  :config
  (defun +evil|simple-matchit ()
    "A hook to force evil-matchit to favor simple bracket jumping. Helpful when
the new algorithm is confusing, like in python or ruby."
    (setq-local evilmi-always-simple-jump t))
  (add-hook 'python-mode-hook #'+evil|simple-matchit))
#+END_SRC

**** evil-mc
Multiple cursors!

#+BEGIN_SRC emacs-lisp
(use-package evil-mc :demand t
  :commands (evil-mc-make-cursor-here evil-mc-make-all-cursors
             evil-mc-undo-all-cursors evil-mc-pause-cursors
             evil-mc-resume-cursors evil-mc-make-and-goto-first-cursor
             evil-mc-make-and-goto-last-cursor
             evil-mc-make-cursor-move-next-line
             evil-mc-make-cursor-move-prev-line evil-mc-make-cursor-at-pos
             evil-mc-has-cursors-p evil-mc-make-and-goto-next-cursor
             evil-mc-skip-and-goto-next-cursor evil-mc-make-and-goto-prev-cursor
             evil-mc-skip-and-goto-prev-cursor evil-mc-make-and-goto-next-match
             evil-mc-skip-and-goto-next-match evil-mc-skip-and-goto-next-match
             evil-mc-make-and-goto-prev-match evil-mc-skip-and-goto-prev-match)
  :config
  (global-evil-mc-mode +1)

  (dolist
      (commands '((evil-change-without-register . ((:default . evil-mc-execute-default-evil-change)))
                 (evil-change-line-without-register . ((:default . evil-mc-execute-default-evil-change-line)))
                 (evil-delete-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                 (evil-delete-without-register-if-whitespace . ((:default . evil-mc-execute-default-evil-delete)))
                 (evil-delete-char-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                 (evil-delete-backward-char-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                 (evil-delete-line-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                 (evil-paste-after-witout-register . ((:default . evil-mc-execute-default-evil-paste)))
                 (evil-paste-before-witout-register . ((:default . evil-mc-execute-default-evil-paste)))))
    (push commands evil-mc-custom-known-commands))

  ;; disable evil-escape in evil-mc; causes unwanted text on invocation
  (push 'evil-escape-mode evil-mc-incompatible-minor-modes)

  (defun evil-mc-maybe-run-cursors-before ()
    "Runs `evil-mc-cursors-before' if there are no cursors created yet."
    (when (not (evil-mc-has-cursors-p))
      (evil-mc-cursors-before)))

  (defun evil-mc-cursors-before ()
    "Actions to be executed before any cursors are created."
    (setq evil-mc-cursor-state (evil-mc-read-cursor-state nil))
    (when (not skip)
      (evil-mc-write-cursor-state
       (evil-mc-put-cursor-last-position (evil-mc-get-default-cursor) (point))))
    (run-hooks 'evil-mc-before-cursors-created))

  (defun evil-mc-make-cursor-move-by-line (dir count)
    "Create COUNT cursors one for each line moving in the direction DIR.
  DIR should be 1 or -1 and COUNT should be a positive integer or nil."
    (setq count (max 0 (or count 1)))
    (dotimes (_ count)
      (evil-mc-maybe-run-cursors-before)
      (evil-mc-make-cursor-at-pos (point))
      (let (line-move-visual)
        (evil-line-move dir))))

  (defun +evil|escape-multiple-cursors ()
    "Clear evil-mc cursors and restore state."
    (when (evil-mc-has-cursors-p)
      (evil-mc-undo-all-cursors)
      (evil-mc-resume-cursors)
      t))
  (add-hook '+evil-esc-hook #'+evil|escape-multiple-cursors))
#+END_SRC

**** evil-snipe
I only really use this for the extended s/S/f/F behavior

#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :commands (evil-snipe-override-mode)
  :init
  (setq evil-snipe-smart-case t
        evil-snipe-scope 'visible
        evil-snipe-repeat-scope 'buffer
        evil-snipe-char-fold t
        evil-snipe-disabled-modes '(magit-mode elfeed-show-mode elfeed-search-mode))
  (add-hook 'bmacs-post-init-hook #'evil-snipe-override-mode))
#+END_SRC

**** evil-surround
Surround text with various delimiters

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :commands (global-evil-surround-mode
             evil-surround-edit
             evil-Surround-edit
             evil-surround-region)
  :config (global-evil-surround-mode 1))
#+END_SRC

**** evil-visualstar
Allow visual selections to be searched using '*'

#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :commands (global-evil-visualstar-mode
             evil-visualstar/begin-search
             evil-visualstar/begin-search-forward
             evil-visualstar/begin-search-backward)
  :init
  (map! :v "*" #'evil-visualstar/begin-search-forward
        :v "#" #'evil-visualstar/begin-search-backward)
  :config
  (global-evil-visualstar-mode 1))
#+END_SRC

**** evil-iedit-state
Add evil states for iedit mode

#+BEGIN_SRC emacs-lisp
(use-package evil-iedit-state
  :commands (evil-iedit-state evil-iedit-state/iedit-mode)
  :init
  (progn
    (setq iedit-current-symbol-default t
          iedit-only-at-symbol-boundaries t
          iedit-toggle-key-default nil)))
#+END_SRC


**** evil-args
Treat arguments as text objects using 'a'

#+BEGIN_SRC emacs-lisp
(use-package evil-args
  :after evil
  :commands (evil-inner-arg evil-outer-arg
             evil-forward-arg evil-backward-arg
             evil-jump-out-args)
  :config

  (map! :textobj "a" #'evil-inner-arg #'evil-outer-arg))
#+END_SRC

**** evil-textobj-anyblock
Treat simple code blocks as text objects using 'b'

#+BEGIN_SRC emacs-lisp
(use-package evil-textobj-anyblock
  :commands (evil-textobj-anyblock-inner-block evil-textobj-anyblock-a-block)
  :config
  (map! :textobj "b" #'evil-textobj-anyblock-inner-block #'evil-textobj-anyblock-a-block))
#+END_SRC

*** TODO Editorconfig?

*** hideshow
Allows code folding

#+BEGIN_SRC emacs-lisp
(use-package hideshow :demand t ; built-in
  :commands (hs-minor-mode hs-toggle-hiding hs-already-hidden-p hs-hide-level hs-show-all)
  :config
  (add-hook 'prog-mode-hook #'hs-minor-mode)
  (setq hs-hide-comments-when-hiding-all nil))
#+END_SRC

*** undo-tree
Branching undo

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :demand t
  :config
  (global-undo-tree-mode +1)
  ;; persistent undo history is known to cause undo history corruption, which
  ;; can be very destructive! So disable it!
  (setq undo-tree-auto-save-history nil
        undo-tree-history-directory-alist
        (list (cons "." (concat bmacs-cache-dir "undo-tree-hist/")))))
#+END_SRC

*** expand-region
Allows us to increase selected region by semantic units

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands (er/expand-region er/contract-region er/mark-symbol er/mark-word))
#+END_SRC

*** clean-aindent-mode
Auto indentation

#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode :demand t
  :config
  (clean-aindent-mode t)
  (define-key global-map (kbd "RET") 'newline-and-indent))
#+END_SRC

*** iedit - TODO: experiment removing this
Everyone knows iedit!

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :commands (iedit-mode)
  :config
  (map! :map iedit-mode-occurrence-keymap
        :n [escape] 'iedit-quit))
#+END_SRC

*** TODO yasnippet?

*** flycheck
Check syntax!

#+BEGIN_SRC emacs-lisp
(autoload 'pkg-info-version-info "pkg-info")

(use-package flycheck
  :commands (flycheck-mode flycheck-list-errors flycheck-buffer)
  :config
  ;; Emacs feels snappier without checks on idle/change
  (setq flycheck-check-syntax-automatically '(save mode-enabled))

  ;(set! :popup 'flycheck-error-list-mode :select t :autokill t) TODO

  (after! evil
    ;; Flycheck buffer on ESC in normal mode.
    (defun +syntax-checkers|flycheck-buffer ()
      (when flycheck-mode
        (ignore-errors (flycheck-buffer))
        nil))
    (add-hook '+evil-esc-hook #'+syntax-checkers|flycheck-buffer t)))


(use-package flycheck-pos-tip
  :after flycheck
  :config
  (setq flycheck-pos-tip-timeout 10
        flycheck-display-errors-delay 0.5)
  (flycheck-pos-tip-mode +1))
#+END_SRC

** Git

*** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-status magit-blame magit-log-buffer-file))
#+END_SRC

*** gitconfig-mode

#+BEGIN_SRC emacs-lisp
(use-package gitconfig-mode
  :mode "/\\.?git/?config$"
  :mode "/\\.gitmodules$")
#+END_SRC

*** gitignore-mode

#+BEGIN_SRC emacs-lisp
(use-package gitignore-mode
  :mode "/\\.gitignore$")
#+END_SRC

*** git-gutter-fringe

#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :commands git-gutter-mode
  :init
  (defun +version-control|git-gutter-maybe ()
    "Enable `git-gutter-mode' in non-remote buffers."
    (when (and (buffer-file-name)
               (not (file-remote-p (buffer-file-name))))
      (git-gutter-mode +1)))
  (add-hook 'text-mode #'+version-control|git-gutter-maybe)
  (add-hook 'prog-mode #'+version-control|git-gutter-maybe)
  (add-hook 'conf-mode #'+version-control|git-gutter-maybe)
    ;; :config
    ;; (set! :popup "^\\*git-gutter.+\\*$" :regexp t :size 15 :noselect t) TODO
    ;; TODO - take git gutter hydra??
  :config
  ;; Update git-gutter on focus (in case I was using git externally)
  (add-hook 'focus-in-hook #'git-gutter:update-all-windows)

  (after! evil
    (defun +version-control|update-git-gutter ()
      "Refresh git-gutter on ESC. Return nil to prevent shadowing other
`+evil-esc-hook' hooks."
      (when git-gutter-mode
        (ignore (git-gutter))))
    (add-hook '+evil-esc-hook #'+version-control|update-git-gutter t))

    ;; Update git-gutter on focus (in case I was using git externally)
    (add-hook 'focus-in-hook #'git-gutter:update-all-windows))
#+END_SRC


*** gist
Easy upload and linking of gists

#+BEGIN_SRC emacs-lisp
(use-package gist
  :commands (gist-list gist-buffer gist-region gist-buffer-private gist-region-private))
#+END_SRC

*** git-timemachine
Go back in time ... at least in your code

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands (git-timemachine git-timemachine-toggle)
  :config
  (require 'magit-blame)

  ;; Force evil to rehash keybindings for the current state
  (add-hook 'git-timemachine-mode-hook #'evil-force-normal-state))
#+END_SRC

*** git-link

#+BEGIN_SRC emacs-lisp
(use-package git-link
  :commands (git-link git-link-commit git-link-homepage))

(defvar git-link-open-in-browser)

(defun bmacs/git-browse ()
  "Open the website for the current version controlled file. Fallback to
repository root."
  (interactive)
  (require 'git-link)
  (cl-destructuring-bind (beg end)
      (if buffer-file-name (git-link--get-region))
    (let ((git-link-open-in-browser t))
      (git-link (git-link--select-remote) beg end))))
#+END_SRC

*** evil-magit - TODO: do I still want this, experiment with default keybinds

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :after magit
  :init (setq evil-magit-want-horizontal-movement t))
#+END_SRC

** UI

*** all-the-icons
Allows us to show pretty icons in Emacs.

#+BEGIN_SRC emacs-lisp

(use-package all-the-icons
  :commands (all-the-icons-octicon all-the-icons-faicon all-the-icons-fileicon
             all-the-icons-wicon all-the-icons-material all-the-icons-alltheicon
             all-the-icons-install-fonts)
  :init
  (defun disable-all-the-icons-in-tty (orig-fn &rest args)
    (when (display-graphic-p)
      (apply orig-fn args)))

  ;; all-the-icons doesn't work in the terminal, so we "disable" it.
  (advice-add #'all-the-icons-octicon    :around #'disable-all-the-icons-in-tty)
  (advice-add #'all-the-icons-material   :around #'disable-all-the-icons-in-tty)
  (advice-add #'all-the-icons-faicon     :around #'disable-all-the-icons-in-tty)
  (advice-add #'all-the-icons-fileicon   :around #'disable-all-the-icons-in-tty)
  (advice-add #'all-the-icons-wicon      :around #'disable-all-the-icons-in-tty)
  (advice-add #'all-the-icons-alltheicon :around #'disable-all-the-icons-in-tty))
#+END_SRC

*** vi-tilde-fringe
Vi like tilde's in the fringe for past EOF

#+BEGIN_SRC emacs-lisp
(use-package vi-tilde-fringe
  :demand t
  :commands (global-vi-tilde-fringe-mode vi-tilde-fringe-mode)
  :init
  (add-hook 'bmacs-post-init-hook #'global-vi-tilde-fringe-mode)
  :config
  (defun +vi-tilde-fringe|disable ()
    (vi-tilde-fringe-mode -1)))
#+END_SRC

*** doom-themes

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :demand t
  :config
  ;(set! :theme 'doom-one)
  (load-theme 'doom-one t)

  ;; improve integration with org-mode
  (add-hook 'doom-init-ui-hook #'doom-themes-org-config)

  ;; blink mode-line on errors
  (add-hook 'doom-init-ui-hook #'doom-themes-visual-bell-config)

  ;; Add file icons to doom-neotree
  (add-hook 'doom-init-ui-hook #'doom-themes-neotree-config)
  (setq doom-neotree-enable-variable-pitch t
        doom-neotree-file-icons 'simple
        doom-neotree-line-spacing 2))

  ; TODO
  ; (after! neotree
  ;   (defun +doom|neotree-fix-popup ()
  ;     "Ensure the fringe settings are maintained on popup restore."
  ;     (neo-global--when-window
  ;      (doom--neotree-no-fringes)))
  ;   (add-hook 'doom-popup-mode-hook #'+doom|neotree-fix-popup)))

(after! hideshow
  (defface +doom-folded-face
    `((((background dark))
       (:inherit font-lock-comment-face :background ,(doom-color 'base0)))
      (((background light))
       (:inherit font-lock-comment-face :background ,(doom-color 'base3))))
    "Face to hightlight `hideshow' overlays."
    :group 'doom)

  ;; Nicer code-folding overlays (with fringe indicators)
  (setq hs-set-up-overlay
        (lambda (ov)
          (when (eq 'code (overlay-get ov 'hs))
            (overlay-put
             ov 'display (propertize "  [...]  " 'face '+doom-folded-face))))))

(after! flycheck
  ;; because git-gutter is in the left fringe
  (setq flycheck-indication-mode 'right-fringe)
  ;; A non-descript, left-pointing arrow
  (fringe-helper-define 'flycheck-fringe-bitmap-double-arrow 'center
    "...X...."
    "..XX...."
    ".XXX...."
    "XXXX...."
    ".XXX...."
    "..XX...."
    "...X...."))

(after! git-gutter-fringe
  ;; places the git gutter outside the margins.
  (setq-default fringes-outside-margins t)
  ;; thin fringe bitmaps
  (fringe-helper-define 'git-gutter-fr:added '(center repeated)
    "XXX.....")
  (fringe-helper-define 'git-gutter-fr:modified '(center repeated)
    "XXX.....")
  (fringe-helper-define 'git-gutter-fr:deleted 'bottom
    "X......."
    "XX......"
    "XXX....."
    "XXXX...."))
#+END_SRC

*** doom-dashboard
A super cool dashboard on startup!

#+BEGIN_SRC emacs-lisp
  (defvar +doom-dashboard-name " *doom*"
    "The name to use for the dashboard buffer.")

  (defvar +doom-dashboard-inhibit-refresh nil
    "If non-nil, the doom buffer won't be refreshed.")

  (defvar +doom-dashboard-widgets '(banner shortmenu loaded)
    "List of widgets to display in a blank scratch buffer.")

  (defvar +doom-dashboard-inhibit-functions ()
    "A list of functions that determine whether to inhibit the dashboard the
  loading.")

  (defvar doom-fallback-buffer "*scratch*"
    "The name of the buffer to fall back to if no other buffers exist (will create
  it if it doesn't exist).") ;; TODO Not here

  (defun doom-fallback-buffer ()
    "Returns the fallback buffer, creating it if necessary. By default this is the
  scratch buffer."
    (get-buffer-create doom-fallback-buffer))

  (defvar +doom-dashboard--width 80)
  (defvar +doom-dashboard--height 0)
  (defvar +doom-dashboard--old-fringe-indicator fringe-indicator-alist)

  (setq doom-fallback-buffer +doom-dashboard-name)


  (define-derived-mode +doom-dashboard-mode special-mode
    (format "BMACS v%s" "0.1.0")
    "Major mode for the BMACS dashboard buffer."
    (read-only-mode +1)
    (setq truncate-lines t)
    (cl-loop for (car . _cdr) in fringe-indicator-alist
             collect (cons car nil) into alist
             finally do (setq fringe-indicator-alist alist)))

  (map! :map +doom-dashboard-mode-map
        "n" #'+doom-dashboard/next-button
        "p" #'+doom-dashboard/previous-button
        "N" #'+doom-dashboard/last-button
        "P" #'+doom-dashboard/first-button
        :em "j" #'+doom-dashboard/next-button
        :em "k" #'+doom-dashboard/previous-button
        :em "gg" #'+doom-dashboard/first-button
        :em "G"  #'+doom-dashboard/last-button
        [remap evil-insert]      #'evil-normal-state
        [remap evil-change]      #'evil-normal-state
        [remap evil-visual-char] #'evil-normal-state
        [remap evil-visual-line] #'evil-normal-state
        [remap evil-delete]      #'evil-normal-state
        [remap evil-delete-char] #'evil-normal-state)

  ;;
  (defun +doom-dashboard|init ()
    "Initialize doom-dashboard and set up its hooks; possibly open the dashboard
  if in a GUI/non-daemon session."
    (add-hook 'window-configuration-change-hook #'+doom-dashboard-reload)
    (add-hook 'focus-in-hook #'+doom-dashboard-reload)
    (add-hook 'kill-buffer-query-functions #'+doom-dashboard|kill-buffer-query-fn)
    (when (and (display-graphic-p) (not (daemonp)))
      (let ((default-directory bmacs-emacs-dir))
        (+doom-dashboard/open (selected-frame)))))

  (defun +doom-dashboard|kill-buffer-query-fn ()
    (or (not (+doom-dashboard-p))
        (ignore (let (+doom-dashboard-inhibit-refresh)
                  (ignore-errors (+doom-dashboard-reload))))))

  (defun +doom-dashboard|make-frame (frame)
    "Reload the dashboard after a brief pause. This is necessary for new frames,
  whose dimensions may not be fully initialized by the time this is run."
    (run-with-timer 0.1 nil #'+doom-dashboard/open frame))

  (defun +doom-dashboard|server-visit (&rest _)
    "Inhibit dashboard refresh when opening files via emacsclient."
    (setq +doom-dashboard-inhibit-refresh t))

  ;;
  (defun +doom-dashboard/open (frame)
    (interactive (list (selected-frame)))
    (unless (run-hook-with-args-until-success '+doom-dashboard-inhibit-functions)
      (unless +doom-dashboard-inhibit-refresh
        (with-selected-frame frame
          (switch-to-buffer (doom-fallback-buffer))
          (+doom-dashboard-reload)))
      (setq +doom-dashboard-inhibit-refresh nil)))

  (defun +doom-dashboard-p (&optional buffer)
    "Returns t if BUFFER is the dashboard buffer."
    (let ((buffer (or buffer (current-buffer))))
      (and (buffer-live-p buffer)
           (eq buffer (doom-fallback-buffer)))))

  (defun +doom-dashboard-center (len s)
    (concat (make-string (ceiling (max 0 (- len (length s))) 2) ? )
            s))

  (defun +doom-dashboard-reload (&optional dir)
    "Update the DOOM scratch buffer (or create it, if it doesn't exist)."
    (when (get-buffer-window (doom-fallback-buffer))
      (unless (or +doom-dashboard-inhibit-refresh
                  (window-minibuffer-p (frame-selected-window)))
        (let ((old-pwd (or dir default-directory))
              (fallback-buffer (doom-fallback-buffer)))
          (with-current-buffer fallback-buffer
            (with-silent-modifications
              (unless (eq major-mode '+doom-dashboard-mode)
                (+doom-dashboard-mode))
              (erase-buffer)
              (setq default-directory old-pwd)
              (let ((+doom-dashboard--height (window-height (get-buffer-window fallback-buffer)))
                    (lines 1)
                    content)
                (with-temp-buffer
                  (dolist (widget-name +doom-dashboard-widgets)
                    (funcall (intern (format "doom-dashboard-widget--%s" widget-name)))
                    (insert "\n"))
                  (setq content (buffer-string)
                        lines (count-lines (point-min) (point-max))))
                (insert (make-string (max 0 (- (/ +doom-dashboard--height 2)
                                               (/ lines 2)))
                                     ?\n)
                        content))
              (unless (button-at (point))
                (goto-char (next-button (point-min))))))))
      ;; Update all dashboard windows
      (dolist (win (get-buffer-window-list (doom-fallback-buffer) nil t))
        (set-window-fringes win 0 0)
        (set-window-margins
         win (max 0 (/ (- (window-total-width win) +doom-dashboard--width) 2)))))
    t)

  ;; widgets
  (defun doom-dashboard-widget--banner ()
    (mapc (lambda (line)
            (insert (propertize (+doom-dashboard-center +doom-dashboard--width line)
                                'face 'font-lock-comment-face) " ")
            (insert "\n"))
          '("$$$$$$$\\  $$\\      $$\\  $$$$$$\\   $$$$$$\\   $$$$$$   "
            "$$  __$$\\ $$$\\    $$$ |$$  __$$\\ $$  __$$\\ $$  __$$\\ "
            "$$ |  $$ |$$$$\\  $$$$ |$$ /  $$ |$$ /  \\__|$$ /  \\__|"
            "$$$$$$$\\ |$$\\$$\\$$ $$ |$$$$$$$$ |$$ |      \\$$$$$$\\  "
            "$$  __$$\\ $$ \\$$$  $$ |$$  __$$ |$$ |       \\____$$\\ "
            "$$ |  $$ |$$ |\\$  /$$ |$$ |  $$ |$$ |  $$\\ $$\\   $$ |"
            "$$$$$$$  |$$ | \\_/ $$ |$$ |  $$ |\\$$$$$$  |\\$$$$$$  |"
            "\\_______/ \\__|     \\__|\\__|  \\__| \\______/  \\______/ "
            "                                                     "
            "                        EMACS                        ")))

  (defun doom-dashboard-widget--loaded ()
    (insert
     "\n"
     (propertize
      (+doom-dashboard-center
       +doom-dashboard--width
         (format "All loaded up!"))
       ;; (format "Loaded %d packages in %d modules in %.02fs"
       ;;         (- (length load-path) (length doom--base-load-path))
       ;;         (hash-table-size doom-modules)
       ;;         (if (floatp doom-init-time) doom-init-time 0.0))) TODO
      'face 'font-lock-comment-face)
     "\n"))

  (defvar all-the-icons-scale-factor)
  (defvar all-the-icons-default-adjust)
  (defun doom-dashboard-widget--shortmenu ()
    (let ((all-the-icons-scale-factor 1.45)
          (all-the-icons-default-adjust -0.02))
      (mapc (lambda (btn)
              (when btn
                (cl-destructuring-bind (label icon fn) btn
                  (insert
                   (with-temp-buffer
                     (insert-text-button
                      (concat (all-the-icons-octicon icon :face 'font-lock-keyword-face)
                              (propertize (concat " " label) 'face 'font-lock-keyword-face))
                      'action `(lambda (_) ,fn)
                      'follow-link t)
                     (+doom-dashboard-center (- +doom-dashboard--width 2) (buffer-string)))
                   "\n\n"))))
            `(("Homepage" "mark-github"
               (browse-url "https://github.com/gilbertw1/bmacs"))
              ,(when (and (file-exists-p (expand-file-name persp-auto-save-fname persp-save-dir)))
                 '("Reload last session" "history"
                   (+workspace/load-session)))
              ("Recently opened files" "file-text"
               (call-interactively (command-remapping 'recentf-open-files)))
              ("Open project" "briefcase"
               (call-interactively (command-remapping 'projectile-switch-project)))
              ("Jump to bookmark" "bookmark"
               (call-interactively (command-remapping 'bookmark-jump)))
              ("Edit emacs.d" "tools"
               (find-file (expand-file-name "init.el" bmacs-emacs-dir)))))))

  (defun +doom-dashboard/next-button ()
    (interactive)
    (ignore-errors (goto-char (next-button (point)))))

  (defun +doom-dashboard/previous-button ()
    (interactive)
    (ignore-errors (goto-char (previous-button (point)))))

  (defun +doom-dashboard/first-button ()
    (interactive)
    (goto-char (point-min))
    (+doom-dashboard/next-button))

  (defun +doom-dashboard/last-button ()
    (interactive)
    (goto-char (point-max))
    (+doom-dashboard/previous-button)
    (beginning-of-line-text))


  (add-hook 'window-setup-hook #'+doom-dashboard|init)
  (add-hook 'after-make-frame-functions #'+doom-dashboard|make-frame)
  (add-hook 'server-visit-hook #'+doom-dashboard|server-visit)
  (add-hook '+doom-dashboard-mode-hook #'+vi-tilde-fringe|disable)
#+END_SRC

*** doom-modeline
The awesome modeline from Doom

#+BEGIN_SRC emacs-lisp
(defvar-local doom--modeline-format nil
  "The modeline format to use when `doom-hide-modeline-mode' is active. Don't
set this directly. Let-bind it instead.")
(defvar-local doom--old-modeline-format nil
  "The old modeline format, so `doom-hide-modeline-mode' can revert when it's
disabled.")
(define-minor-mode doom-hide-modeline-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :global nil
  (if doom-hide-modeline-mode
      (setq doom--old-modeline-format mode-line-format
            mode-line-format doom--modeline-format)
    (setq mode-line-format doom--old-modeline-format
          doom--old-modeline-format nil))
  (force-mode-line-update))
;; Ensure major-mode or theme changes don't overwrite these variables
(put 'doom--modeline-format 'permanent-local t)
(put 'doom--old-modeline-format 'permanent-local t)
(put 'doom-hide-modeline-mode 'permanent-local t)

(defun doom|hide-modeline-mode-reset ()
  "Sometimes, a major-mode is activated after `doom-hide-modeline-mode' is
activated, thus disabling it (because changing major modes invokes
`kill-all-local-variables' and specifically seems to kill `mode-line-format's
local value, whether or not it's permanent-local. Therefore, we cycle
`doom-hide-modeline-mode' to fix this."
  (when doom-hide-modeline-mode
    (doom-hide-modeline-mode -1)
    (doom-hide-modeline-mode +1)))
(add-hook 'after-change-major-mode-hook #'doom|hide-modeline-mode-reset)


(defmacro def-modeline-segment! (name &rest forms)
  "Defines a modeline segment and byte compiles it."
  (declare (indent defun) (doc-string 2))
  (let ((sym (intern (format "doom-modeline-segment--%s" name))))
    `(progn
       (defun ,sym () ,@forms)
       ,(unless (bound-and-true-p byte-compile-current-file)
          `(let (byte-compile-warnings)
             (byte-compile #',sym))))))

(defsubst doom--prepare-modeline-segments (segments)
  (cl-loop for seg in segments
           if (stringp seg)
            collect seg
           else
            collect (list (intern (format "doom-modeline-segment--%s" (symbol-name seg))))))

(defmacro def-modeline! (name lhs &optional rhs)
  "Defines a modeline format and byte-compiles it. NAME is a symbol to identify
it (used by `doom-modeline' for retrieval). LHS and RHS are lists of symbols of
modeline segments defined with `def-modeline-segment!'.
Example:
  (def-modeline! minimal
    (bar matches \" \" buffer-info)
    (media-info major-mode))
  (doom-set-modeline 'minimal t)"
  (let ((sym (intern (format "doom-modeline-format--%s" name)))
        (lhs-forms (doom--prepare-modeline-segments lhs))
        (rhs-forms (doom--prepare-modeline-segments rhs)))
    `(progn
       (defun ,sym ()
         (let ((lhs (list ,@lhs-forms))
               (rhs (list ,@rhs-forms)))
           (let ((rhs-str (format-mode-line rhs)))
             (list lhs
                   (propertize
                    " " 'display
                    `((space :align-to (- (+ right right-fringe right-margin)
                                          ,(+ 1 (string-width rhs-str))))))
                   rhs-str))))
       ,(unless (bound-and-true-p byte-compile-current-file)
          `(let (byte-compile-warnings)
             (byte-compile #',sym))))))

(defun doom-modeline (key)
  "Returns a mode-line configuration associated with KEY (a symbol). Throws an
error if it doesn't exist."
  (let ((fn (intern (format "doom-modeline-format--%s" key))))
    (when (functionp fn)
      `(:eval (,fn)))))

(defun doom-set-modeline (key &optional default)
  "Set the modeline format. Does nothing if the modeline KEY doesn't exist. If
DEFAULT is non-nil, set the default mode-line for all buffers."
  (when-let (modeline (doom-modeline key))
    (setf (if default
              (default-value 'mode-line-format)
            (buffer-local-value 'mode-line-format (current-buffer)))
          modeline)))


;; no modeline in completion popups
(add-hook 'completion-list-mode-hook #'doom-hide-modeline-mode)

(use-package eldoc-eval
  :demand t
  :config
  (defun +doom-modeline-eldoc (text)
    (concat (when (display-graphic-p)
              (+doom-modeline--make-xpm
               (face-background 'doom-modeline-eldoc-bar nil t)
               +doom-modeline-height
               +doom-modeline-bar-width))
            text))

  ;; Show eldoc in the mode-line with `eval-expression'
  (defun +doom-modeline--show-eldoc (input)
    "Display string STR in the mode-line next to minibuffer."
    (with-current-buffer (eldoc-current-buffer)
      (let* ((str              (and (stringp input) input))
             (mode-line-format (or (and str (or (+doom-modeline-eldoc str) str))
                                   mode-line-format))
             mode-line-in-non-selected-windows)
        (force-mode-line-update)
        (sit-for eldoc-show-in-mode-line-delay))))

  (setq eldoc-in-minibuffer-show-fn #'+doom-modeline--show-eldoc)
  (eldoc-in-minibuffer-mode +1))

;; anzu and evil-anzu expose current/total state that can be displayed in the
;; mode-line.
(use-package evil-anzu
  :when (featurep 'evil)
  :init
  (add-transient-hook! #'evil-ex-start-search (require 'evil-anzu))
  (add-transient-hook! #'evil-ex-start-word-search (require 'evil-anzu))
  :config
  (setq anzu-cons-mode-line-p nil
        anzu-minimum-input-length 1
        anzu-search-threshold 250)

  ;; Avoid anzu conflicts across buffers
  (mapc #'make-variable-buffer-local
        '(anzu--total-matched anzu--current-position anzu--state
          anzu--cached-count anzu--cached-positions anzu--last-command
          anzu--last-isearch-string anzu--overflow-p))

  ;; Ensure anzu state is cleared when searches & iedit are done
  (add-hook 'isearch-mode-end-hook #'anzu--reset-status t)
  (add-hook '+evil-esc-hook #'anzu--reset-status t)
  (add-hook 'iedit-mode-end-hook #'anzu--reset-status))


;; Keep `+doom-modeline-current-window' up-to-date
(defvar +doom-modeline-current-window (frame-selected-window))
(defun +doom-modeline|set-selected-window (&rest _)
  "Sets `+doom-modeline-current-window' appropriately"
  (let ((win (frame-selected-window)))
    (unless (minibuffer-window-active-p win)
      (setq +doom-modeline-current-window win))))

(add-hook 'window-configuration-change-hook #'+doom-modeline|set-selected-window)
(add-hook 'focus-in-hook #'+doom-modeline|set-selected-window)
(advice-add #'handle-switch-frame :after #'+doom-modeline|set-selected-window)
(advice-add #'select-window :after #'+doom-modeline|set-selected-window)

;; fish-style modeline
(use-package shrink-path
  :commands (shrink-path-prompt shrink-path-file-mixed))


;;
;; Variables
;;

(defvar +doom-modeline-height 29
  "How tall the mode-line should be (only respected in GUI emacs).")

(defvar +doom-modeline-bar-width 3
  "How wide the mode-line bar should be (only respected in GUI emacs).")

(defvar +doom-modeline-vspc
  (propertize " " 'face 'variable-pitch)
  "TODO")

(defvar +doom-modeline-buffer-file-name-style 'truncate-upto-project
  "Determines the style used by `+doom-modeline-buffer-file-name'.
Given ~/Projects/FOSS/emacs/lisp/comint.el
truncate-upto-project => ~/P/F/emacs/lisp/comint.el
truncate-upto-root => ~/P/F/e/lisp/comint.el
truncate-all => ~/P/F/e/l/comint.el
relative-from-project => emacs/lisp/comint.el
relative-to-project => lisp/comint.el
file-name => comint.el")

;; externs
(defvar anzu--state nil)
(defvar evil-mode nil)
(defvar evil-state nil)
(defvar evil-visual-selection nil)
(defvar iedit-mode nil)
(defvar all-the-icons-scale-factor)
(defvar all-the-icons-default-adjust)


;;
;; Custom faces
;;

(defgroup +doom-modeline nil
  ""
  :group 'doom)

(defface doom-modeline-buffer-path
  '((t (:inherit mode-line-emphasis :bold t)))
  "Face used for the dirname part of the buffer path."
  :group '+doom-modeline)

(defface doom-modeline-buffer-file
  '((t (:inherit mode-line-buffer-id)))
  "Face used for the filename part of the mode-line buffer path."
  :group '+doom-modeline)

(defface doom-modeline-buffer-modified
  '((t (:inherit error :background nil :bold t)))
  "Face used for the 'unsaved' symbol in the mode-line."
  :group '+doom-modeline)

(defface doom-modeline-buffer-major-mode
  '((t (:inherit mode-line-emphasis :bold t)))
  "Face used for the major-mode segment in the mode-line."
  :group '+doom-modeline)

(defface doom-modeline-highlight
  '((t (:inherit mode-line-emphasis)))
  "Face for bright segments of the mode-line."
  :group '+doom-modeline)

(defface doom-modeline-panel
  '((t (:inherit mode-line-highlight)))
  "Face for 'X out of Y' segments, such as `+doom-modeline--anzu', `+doom-modeline--evil-substitute' and
`iedit'"
  :group '+doom-modeline)

(defface doom-modeline-info
  `((t (:inherit success :bold t)))
  "Face for info-level messages in the modeline. Used by `*vc'."
  :group '+doom-modeline)

(defface doom-modeline-warning
  `((t (:inherit warning :bold t)))
  "Face for warnings in the modeline. Used by `*flycheck'"
  :group '+doom-modeline)

(defface doom-modeline-urgent
  `((t (:inherit error :bold t)))
  "Face for errors in the modeline. Used by `*flycheck'"
  :group '+doom-modeline)

;; Bar
(defface doom-modeline-bar '((t (:inherit highlight)))
  "The face used for the left-most bar on the mode-line of an active window."
  :group '+doom-modeline)

(defface doom-modeline-eldoc-bar '((t (:inherit shadow)))
  "The face used for the left-most bar on the mode-line when eldoc-eval is
active."
  :group '+doom-modeline)

(defface doom-modeline-inactive-bar '((t (:inherit warning :inverse-video t)))
  "The face used for the left-most bar on the mode-line of an inactive window."
  :group '+doom-modeline)


;;
;; Modeline helpers
;;

(defsubst active ()
  (eq (selected-window) +doom-modeline-current-window))

;; Inspired from `powerline's `pl/make-xpm'.
(def-memoized! +doom-modeline--make-xpm (color height width)
  "Create an XPM bitmap."
  (propertize
   " " 'display
   (let ((data (make-list height (make-list width 1)))
         (color (or color "None")))
     (create-image
      (concat
       (format "/* XPM */\nstatic char * percent[] = {\n\"%i %i 2 1\",\n\". c %s\",\n\"  c %s\","
               (length (car data))
               (length data)
               color
               color)
       (apply #'concat
              (cl-loop with idx = 0
                       with len = (length data)
                       for dl in data
                       do (cl-incf idx)
                       collect
                       (concat "\""
                               (cl-loop for d in dl
                                        if (= d 0) collect (string-to-char " ")
                                        else collect (string-to-char "."))
                               (if (eq idx len) "\"};" "\",\n")))))
      'xpm t :ascent 'center))))

(defun +doom-modeline-buffer-file-name ()
  "Propertized `buffer-file-name' based on `+doom-modeline-buffer-file-name-style'."
  (propertize
   (pcase +doom-modeline-buffer-file-name-style
     ('truncate-upto-project (+doom-modeline--buffer-file-name 'shrink))
     ('truncate-upto-root (+doom-modeline--buffer-file-name-truncate))
     ('truncate-all (+doom-modeline--buffer-file-name-truncate t))
     ('relative-to-project (+doom-modeline--buffer-file-name-relative))
     ('relative-from-project (+doom-modeline--buffer-file-name-relative 'include-project))
     ('file-name (propertize (file-name-nondirectory buffer-file-name)
                             'face
                             (let ((face (or (and (buffer-modified-p)
                                                  'doom-modeline-buffer-modified)
                                             (and (active)
                                                  'doom-modeline-buffer-file))))
                               (when face `(:inherit ,face))))))
   'help-echo buffer-file-truename))

(defun +doom-modeline--buffer-file-name-truncate (&optional truncate-tail)
  "Propertized `buffer-file-name' that truncates every dir along path.
If TRUNCATE-TAIL is t also truncate the parent directory of the file."
  (let ((dirs (shrink-path-prompt (file-name-directory
                                   (or buffer-file-truename
                                       (file-truename buffer-file-name)))))
        (active (active)))
    (if (null dirs)
        (propertize "%b" 'face (if active 'doom-modeline-buffer-file))
      (let ((modified-faces (if (buffer-modified-p) 'doom-modeline-buffer-modified)))
        (let ((dirname (car dirs))
              (basename (cdr dirs))
              (dir-faces (or modified-faces (if active 'doom-modeline-project-root-dir)))
              (file-faces (or modified-faces (if active 'doom-modeline-buffer-file))))
          (concat (propertize (concat dirname
                                      (if truncate-tail (substring basename 0 1) basename)
                                      "/")
                              'face (if dir-faces `(:inherit ,dir-faces)))
                  (propertize (file-name-nondirectory buffer-file-name)
                              'face (if file-faces `(:inherit ,file-faces)))))))))

(defun +doom-modeline--buffer-file-name-relative (&optional include-project)
  "Propertized `buffer-file-name' showing directories relative to project's root only."
  (let ((root (bmacs-project-root))
        (active (active)))
    (if (null root)
        (propertize "%b" 'face (if active 'doom-modeline-buffer-file))
      (let* ((modified-faces (if (buffer-modified-p) 'doom-modeline-buffer-modified))
             (relative-dirs (file-relative-name (file-name-directory buffer-file-name)
                                                (if include-project (concat root "../") root)))
             (relative-faces (or modified-faces (if active 'doom-modeline-buffer-path)))
             (file-faces (or modified-faces (if active 'doom-modeline-buffer-file))))
        (if (equal "./" relative-dirs) (setq relative-dirs ""))
        (concat (propertize relative-dirs 'face (if relative-faces `(:inherit ,relative-faces)))
                (propertize (file-name-nondirectory buffer-file-name)
                            'face (if file-faces `(:inherit ,file-faces))))))))

(defun +doom-modeline--buffer-file-name (truncate-project-root-parent)
  "Propertized `buffer-file-name'.
If TRUNCATE-PROJECT-ROOT-PARENT is t space will be saved by truncating it down
fish-shell style.
Example:
~/Projects/FOSS/emacs/lisp/comint.el => ~/P/F/emacs/lisp/comint.el"
  (let* ((project-root (bmacs-project-root))
         (file-name-split (shrink-path-file-mixed project-root
                                                  (file-name-directory
                                                   (or buffer-file-truename
                                                       (file-truename buffer-file-name)))
                                                  (file-truename buffer-file-name)))
         (active (active)))
    (if (null file-name-split)
        (propertize "%b" 'face (if active 'doom-modeline-buffer-file))
      (pcase-let ((`(,root-path-parent ,project ,relative-path ,filename) file-name-split))
        (let ((modified-faces (if (buffer-modified-p) 'doom-modeline-buffer-modified)))
          (let ((sp-faces       (or modified-faces (if active 'font-lock-comment-face)))
                (project-faces  (or modified-faces (if active 'font-lock-string-face)))
                (relative-faces (or modified-faces (if active 'doom-modeline-buffer-path)))
                (file-faces     (or modified-faces (if active 'doom-modeline-buffer-file))))
            (let ((sp-props       `(,@(if sp-faces       `(:inherit ,sp-faces))      ,@(if active '(:weight bold))))
                  (project-props  `(,@(if project-faces  `(:inherit ,project-faces)) ,@(if active '(:weight bold))))
                  (relative-props `(,@(if relative-faces `(:inherit ,relative-faces))))
                  (file-props     `(,@(if file-faces     `(:inherit ,file-faces)))))
              (concat (propertize (if truncate-project-root-parent
                                      root-path-parent
                                    (abbreviate-file-name project-root))
                                  'face sp-props)
                      (propertize (concat project "/") 'face project-props)
                      (when relative-path (propertize relative-path 'face relative-props))
                      (propertize filename 'face file-props)))))))))


;;
;; Segments
;;

(def-modeline-segment! buffer-default-directory
  "Displays `default-directory'. This is for special buffers like the scratch
buffer where knowing the current project directory is important."
  (let ((face (if (active) 'doom-modeline-buffer-path)))
    (concat (if (display-graphic-p) " ")
            (all-the-icons-octicon
             "file-directory"
             :face face
             :v-adjust -0.05
             :height 1.25)
            (propertize (concat " " (abbreviate-file-name default-directory))
                        'face face))))

;;
(def-modeline-segment! buffer-info
  "Combined information about the current buffer, including the current working
directory, the file name, and its state (modified, read-only or non-existent)."
  (let ((all-the-icons-scale-factor 1.2))
    (concat (cond (buffer-read-only
                   (concat (all-the-icons-octicon
                            "lock"
                            :face 'doom-modeline-warning
                            :v-adjust -0.05)
                           " "))
                  ((buffer-modified-p)
                   (concat (all-the-icons-faicon
                            "floppy-o"
                            :face 'doom-modeline-buffer-modified
                            :v-adjust -0.0575)
                           " "))
                  ((and buffer-file-name
                        (not (file-exists-p buffer-file-name)))
                   (concat (all-the-icons-octicon
                            "circle-slash"
                            :face 'doom-modeline-urgent
                            :v-adjust -0.05)
                           " "))
                  ((buffer-narrowed-p)
                   (concat (all-the-icons-octicon
                            "fold"
                            :face 'doom-modeline-warning
                            :v-adjust -0.05)
                           " ")))
            (if buffer-file-name
                (+doom-modeline-buffer-file-name)
              "%b"))))

;;
(def-modeline-segment! buffer-info-simple
  "Display only the current buffer's name, but with fontification."
  (propertize
   "%b"
   'face (cond ((and buffer-file-name (buffer-modified-p))
                'doom-modeline-buffer-modified)
               ((active) 'doom-modeline-buffer-file))))

;;
(def-modeline-segment! buffer-encoding
  "Displays the encoding and eol style of the buffer the same way Atom does."
  (concat (pcase (coding-system-eol-type buffer-file-coding-system)
            (0 "LF  ")
            (1 "CRLF  ")
            (2 "CR  "))
          (let ((sys (coding-system-plist buffer-file-coding-system)))
            (cond ((memq (plist-get sys :category) '(coding-category-undecided coding-category-utf-8))
                   "UTF-8")
                  (t (upcase (symbol-name (plist-get sys :name))))))
          "  "))

;;
(def-modeline-segment! major-mode
  "The major mode, including process, environment and text-scale info."
  (propertize
   (concat (format-mode-line mode-name)
           (when (stringp mode-line-process)
             mode-line-process)
           (and (featurep 'face-remap)
                (/= text-scale-mode-amount 0)
                (format " (%+d)" text-scale-mode-amount)))
   'face (if (active) 'doom-modeline-buffer-major-mode)))

;;
(def-modeline-segment! vcs
  "Displays the current branch, colored based on its state."
  (when (and vc-mode buffer-file-name)
    (let* ((backend (vc-backend buffer-file-name))
           (state   (vc-state buffer-file-name backend)))
      (let ((face    'mode-line-inactive)
            (active  (active))
            (all-the-icons-scale-factor 1.0)
            (all-the-icons-default-adjust -0.1))
        (concat "  "
                (cond ((memq state '(edited added))
                       (if active (setq face 'doom-modeline-info))
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :height 1.2
                        :v-adjust -0.05))
                      ((eq state 'needs-merge)
                       (if active (setq face 'doom-modeline-info))
                       (all-the-icons-octicon "git-merge" :face face))
                      ((eq state 'needs-update)
                       (if active (setq face 'doom-modeline-warning))
                       (all-the-icons-octicon "arrow-down" :face face))
                      ((memq state '(removed conflict unregistered))
                       (if active (setq face 'doom-modeline-urgent))
                       (all-the-icons-octicon "alert" :face face))
                      (t
                       (if active (setq face 'font-lock-doc-face))
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :height 1.2
                        :v-adjust -0.05)))
                " "
                (propertize (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2))
                            'face (if active face))
                " ")))))

;;
(defun +doom-ml-icon (icon &optional text face voffset)
  "Displays an octicon ICON with FACE, followed by TEXT. Uses
`all-the-icons-octicon' to fetch the icon."
  (concat (if vc-mode " " "  ")
          (when icon
            (concat
             (all-the-icons-material icon :face face :height 1.1 :v-adjust (or voffset -0.2))
             (if text +doom-modeline-vspc)))
          (when text
            (propertize text 'face face))
          (if vc-mode "  " " ")))

(def-modeline-segment! flycheck
  "Displays color-coded flycheck error status in the current buffer with pretty
icons."
  (when (boundp 'flycheck-last-status-change)
    (pcase flycheck-last-status-change
      ('finished (if flycheck-current-errors
                     (let-alist (flycheck-count-errors flycheck-current-errors)
                       (let ((sum (+ (or .error 0) (or .warning 0))))
                         (+doom-ml-icon "do_not_disturb_alt"
                                        (number-to-string sum)
                                        (if .error 'doom-modeline-urgent 'doom-modeline-warning)
                                        -0.25)))
                   (+doom-ml-icon "check" nil 'doom-modeline-info)))
      ('running     (+doom-ml-icon "access_time" nil 'font-lock-doc-face -0.25))
      ('no-checker  (+doom-ml-icon "sim_card_alert" "-" 'font-lock-doc-face))
      ('errored     (+doom-ml-icon "sim_card_alert" "Error" 'doom-modeline-urgent))
      ('interrupted (+doom-ml-icon "pause" "Interrupted" 'font-lock-doc-face)))))
      ;; ('interrupted (+doom-ml-icon "x" "Interrupted" 'font-lock-doc-face)))))

;;
(defsubst doom-column (pos)
  (save-excursion (goto-char pos)
                  (current-column)))

(def-modeline-segment! selection-info
  "Information about the current selection, such as how many characters and
lines are selected, or the NxM dimensions of a block selection."
  (when (and (active) (or mark-active (eq evil-state 'visual)))
    (let ((reg-beg (region-beginning))
          (reg-end (region-end)))
      (propertize
       (let ((lines (count-lines reg-beg (min (1+ reg-end) (point-max)))))
         (cond ((or (bound-and-true-p rectangle-mark-mode)
                    (eq 'block evil-visual-selection))
                (let ((cols (abs (- (doom-column reg-end)
                                    (doom-column reg-beg)))))
                  (format "%dx%dB" lines cols)))
               ((eq 'line evil-visual-selection)
                (format "%dL" lines))
               ((> lines 1)
                (format "%dC %dL" (- (1+ reg-end) reg-beg) lines))
               (t
                (format "%dC" (- (1+ reg-end) reg-beg)))))
       'face 'doom-modeline-highlight))))


;;
(defun +doom-modeline--macro-recording ()
  "Display current Emacs or evil macro being recorded."
  (when (and (active) (or defining-kbd-macro executing-kbd-macro))
    (let ((sep (propertize " " 'face 'doom-modeline-panel)))
      (concat sep
              (propertize (if (bound-and-true-p evil-this-macro)
                              (char-to-string evil-this-macro)
                            "Macro")
                          'face 'doom-modeline-panel)
              sep
              (all-the-icons-octicon "triangle-right"
                                     :face 'doom-modeline-panel
                                     :v-adjust -0.05)
              sep))))

(defsubst +doom-modeline--anzu ()
  "Show the match index and total number thereof. Requires `anzu', also
`evil-anzu' if using `evil-mode' for compatibility with `evil-search'."
  (when (and anzu--state (not iedit-mode))
    (propertize
     (let ((here anzu--current-position)
           (total anzu--total-matched))
       (cond ((eq anzu--state 'replace-query)
              (format " %d replace " total))
             ((eq anzu--state 'replace)
              (format " %d/%d " here total))
             (anzu--overflow-p
              (format " %s+ " total))
             (t
              (format " %s/%d " here total))))
     'face (if (active) 'doom-modeline-panel))))

(defsubst +doom-modeline--evil-substitute ()
  "Show number of matches for evil-ex substitutions and highlights in real time."
  (when (and evil-mode
             (or (assq 'evil-ex-substitute evil-ex-active-highlights-alist)
                 (assq 'evil-ex-global-match evil-ex-active-highlights-alist)
                 (assq 'evil-ex-buffer-match evil-ex-active-highlights-alist)))
    (propertize
     (let ((range (if evil-ex-range
                      (cons (car evil-ex-range) (cadr evil-ex-range))
                    (cons (line-beginning-position) (line-end-position))))
           (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
       (if pattern
           (format " %s matches " (how-many pattern (car range) (cdr range)))
         " - "))
     'face (if (active) 'doom-modeline-panel))))

(defun doom-themes--overlay-sort (a b)
  (< (overlay-start a) (overlay-start b)))

(defsubst +doom-modeline--iedit ()
  "Show the number of iedit regions matches + what match you're on."
  (when (and iedit-mode iedit-occurrences-overlays)
    (propertize
     (let ((this-oc (or (let ((inhibit-message t))
                          (iedit-find-current-occurrence-overlay))
                        (progn (iedit-prev-occurrence)
                               (iedit-find-current-occurrence-overlay))))
           (length (length iedit-occurrences-overlays)))
       (format " %s/%d "
               (if this-oc
                   (- length
                      (length (memq this-oc (sort (append iedit-occurrences-overlays nil)
                                                  #'doom-themes--overlay-sort)))
                      -1)
                 "-")
               length))
     'face (if (active) 'doom-modeline-panel))))

(def-modeline-segment! matches
  "Displays: 1. the currently recording macro, 2. A current/total for the
current search term (with anzu), 3. The number of substitutions being conducted
with `evil-ex-substitute', and/or 4. The number of active `iedit' regions."
  (let ((meta (concat (+doom-modeline--macro-recording)
                      (+doom-modeline--anzu)
                      (+doom-modeline--evil-substitute)
                      (+doom-modeline--iedit))))
     (or (and (not (equal meta "")) meta)
         (if buffer-file-name " %I "))))

;; TODO Include other information
(def-modeline-segment! media-info
  "Metadata regarding the current file, such as dimensions for images."
  (cond ((eq major-mode 'image-mode)
         (cl-destructuring-bind (width . height)
             (image-size (image-get-display-property) :pixels)
           (format "  %dx%d  " width height)))))

(def-modeline-segment! bar
  "The bar regulates the height of the mode-line in GUI Emacs.
Returns \"\" to not break --no-window-system."
  (if (display-graphic-p)
      (+doom-modeline--make-xpm
       (face-background (if (active)
                            'doom-modeline-bar
                          'doom-modeline-inactive-bar)
                        nil t)
       +doom-modeline-height
       +doom-modeline-bar-width)
    ""))


;;
;; Mode lines
;;

(def-modeline! main
  (bar matches " " buffer-info "  %l:%c %p  " selection-info)
  (buffer-encoding major-mode vcs flycheck))

(def-modeline! minimal
  (bar matches " " buffer-info)
  (media-info major-mode))

(def-modeline! special
  (bar matches " " buffer-info-simple "  %l:%c %p  " selection-info)
  (buffer-encoding major-mode flycheck))

(def-modeline! project
  (bar buffer-default-directory)
  (major-mode))

(def-modeline! media
  (bar " %b  ")
  (media-info major-mode))


;;
;; Hooks
;;

(defun +doom-modeline|init ()
  "Set the default modeline."
  (doom-set-modeline 'main t)

  ;; This scratch buffer is already created and doesn't get a modeline. For the
  ;; love of Emacs, someone give the man a modeline!
  (with-current-buffer "*scratch*"
    (doom-set-modeline 'main)))

(defun +doom-modeline|set-special-modeline ()
  (doom-set-modeline 'special))

(defun +doom-modeline|set-media-modeline ()
  (doom-set-modeline 'media))

(defun +doom-modeline|set-project-modeline ()
  (doom-set-modeline 'project))


;;
;; Bootstrap
;;

(add-hook 'bmacs-post-init-hook #'+doom-modeline|init)
(add-hook 'doom-scratch-buffer-hook #'+doom-modeline|set-special-modeline)
(add-hook '+doom-dashboard-mode-hook #'+doom-modeline|set-project-modeline)

(add-hook 'org-src-mode-hook #'+doom-modeline|set-special-modeline)
(add-hook 'image-mode-hook   #'+doom-modeline|set-media-modeline)
(add-hook 'circe-mode-hook   #'+doom-modeline|set-special-modeline)

#+END_SRC

*** TODO doom-modeline

*** doom-quit
Quit prompt with messages

#+BEGIN_SRC emacs-lisp
(defvar +doom-quit-messages
  '(;; from Doom 1
    "Please don't leave, there's more demons to toast!"
    "Let's beat it -- This is turning into a bloodbath!"
    "I wouldn't leave if I were you. DOS is much worse."
    "Don't leave yet -- There's a demon around that corner!"
    "Ya know, next time you come in here I'm gonna toast ya."
    "Go ahead and leave. See if I care."
    "Are you sure you want to quit this great editor?"
    ;; Custom
    "(setq nothing t everything 'permitted)"
    "Emacs will remember that."
    "Emacs, Emacs never changes."
    "Hey! Hey, M-x listen!"
    "I'm the man who's going to burn your house down! With lemons!"
    "It's not like I'll miss you or anything, b-baka!"
    "Okay, look. We've both said a lot of things you're going to regret..."
    "Wake up, Mr. Stallman. Wake up and smell the ashes."
    "You are *not* prepared!")
  "A list of quit messages, picked randomly by `+doom-quit'. Taken from
http://doom.wikia.com/wiki/Quit_messages and elsewhere.")

(defun +doom|quit (&rest _)
  (doom-quit-p
   (format "%s  Quit?"
           (nth (random (length +doom-quit-messages))
                +doom-quit-messages))))

;;
(remove-hook 'kill-emacs-query-functions #'doom-quit-p)
(add-hook 'kill-emacs-query-functions #'+doom|quit)
#+END_SRC

*** evil-goggles

#+BEGIN_SRC emacs-lisp
(use-package evil-goggles
  :commands evil-goggles-mode
  :init
  (setq evil-goggles-duration 0.2)
  (add-hook 'bmacs-post-init-hook #'evil-goggles-mode t))

(defun +evil-goggles/toggle ()
  "Toggle evil goggles mode."
  (interactive)
  (if evil-goggles-mode
      (evil-goggles-mode -1)
    (evil-goggles-mode +1)))
#+END_SRC

*** hl-todo
Highlight toodledoos

#+BEGIN_SRC emacs-lisp
(defun +hl-todo|use-face-detection ()
  "Use a different, more primitive method of locating todo keywords.

This is useful for major modes that don't use or have a valid syntax-table entry
for comment start/end characters."
  (set (make-local-variable 'hl-todo-keywords)
       '(((lambda (limit)
            (let (case-fold-search)
              (and (re-search-forward hl-todo-regexp limit t)
                   (memq 'font-lock-comment-face (bmacs-enlist (get-text-property (point) 'face))))))
          (1 (hl-todo-get-face) t t))))
  (when hl-todo-mode
    (hl-todo-mode -1)
    (hl-todo-mode +1)))


(use-package hl-todo
  :commands hl-todo-mode
  :init (add-hook 'prog-mode-hook #'hl-todo-mode)
  :config
  (setq hl-todo-keyword-faces
        `(("TODO"  . ,(face-foreground 'warning))
          ("FIXME" . ,(face-foreground 'error))
          ("NOTE"  . ,(face-foreground 'success))))

  ;; Use a more primitive todo-keyword detection method in major modes that
  ;; don't use/have a valid syntax table entry for comments.
  (add-hook 'pug-mode #'+hl-todo|use-face-detection)
  (add-hook 'haml-mode #'+hl-todo|use-face-detection))
#+END_SRC

*** nav-flash

#+BEGIN_SRC emacs-lisp
(defun bmacs*blink-cursor-maybe (orig-fn &rest args)
  "Blink current line if the window has moved."
  (let ((point (save-excursion (goto-char (window-start))
                               (point-marker))))
    (apply orig-fn args)
    (unless (or (derived-mode-p 'term-mode)
                (equal point
                       (save-excursion (goto-char (window-start))
                                       (point-marker))))
      (bmacs/blink-cursor))))

;;;###autoload
(defun bmacs/blink-cursor (&rest _)
  "Blink current line using `nav-flash'."
  (interactive)
  (unless (minibufferp)
    (nav-flash-show)
    ;; only show in the current window
    (overlay-put compilation-highlight-overlay 'window (selected-window))))

(use-package nav-flash
  :commands nav-flash-show
  :init
  ;; NOTE In :feature jump `recenter' is hooked to a bunch of jumping commands,
  ;; which will trigger nav-flash.
  (advice-add #'windmove-do-window-select :around #'bmacs*blink-cursor-maybe)
  (advice-add #'recenter :around #'bmacs*blink-cursor-maybe)

  (after! evil
    (advice-add #'evil-window-top    :after #'bmacs/blink-cursor)
    (advice-add #'evil-window-middle :after #'bmacs/blink-cursor)
    (advice-add #'evil-window-bottom :after #'bmacs/blink-cursor)))

#+END_SRC

*** solaire-mode
Praise the sun!

#+BEGIN_SRC emacs-lisp
; (use-package solaire-mode
;   :commands (solaire-mode turn-on-solaire-mode turn-off-solaire-mode)
;   :init
;   (add-hook 'after-change-major-mode-hook #'turn-on-solaire-mode)
;   :config
;   ;(setq solaire-mode-real-buffer-fn #'doom-real-buffer-p) TODO
;   (add-hook 'bmacs-post-init-hook #'solaire-mode-swap-bg t)
;
;   ;; Extra modes to activate doom-buffer-mode in
;   (add-hook 'gist-mode #'solaire-mode)
;   (add-hook 'mu4e-view-mode #'solaire-mode)
;   (add-hook 'org-tree-slide-mode #'solaire-mode)
;   (add-hook '+regex-mode #'solaire-mode))

#+END_SRC

*** fringe-helper
Adds simple helper functions to define fringe bitmaps.

#+BEGIN_SRC emacs-lisp
(use-package fringe-helper
  :commands (fringe-helper-define fringe-helper-convert)
  :init
  (unless (fboundp 'define-fringe-bitmap)
    ;; doesn't exist in terminal Emacs; define it to prevent errors
    (defun define-fringe-bitmap (&rest _))))
#+END_SRC

*** highlight-indentation
Simply allows indentation to be visibly highlighted

#+BEGIN_SRC emacs-lisp
(use-package highlight-indentation
  :commands (highlight-indentation-mode highlight-indentation-current-column-mode))
#+END_SRC

*** highlight-numbers
Highlights numbers for modes with sub-par number fontification

#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers :commands highlight-numbers-mode)
#+END_SRC

*** hl-line
Highlights the current line

#+BEGIN_SRC emacs-lisp
(use-package hl-line ; built-in
  :demand t
  :init
  (add-hook 'prog-mode #'hl-line-mode)
  (add-hook 'text-mode #'hl-line-mode)
  (add-hook 'conf-mode #'hl-line-mode)
  :config
  ;; I don't need hl-line showing in other windows. This also offers a small
  ;; speed boost when buffer is displayed in multiple windows.
  (setq hl-line-sticky-flag nil
        global-hl-line-sticky-flag nil)

  ;; Disable `hl-line' in evil-visual mode (temporarily). `hl-line' can make
  ;; the selection region harder to see while in evil visual mode.
  (defun bmacs|disable-hl-line () (hl-line-mode -1))

  (add-hook 'evil-visual-state-entry-hook #'bmacs|disable-hl-line)
  (add-hook 'evil-visual-state-exit-hook #'hl-line-mode))
#+END_SRC

*** rainbow-delimiters
Easily distinguish the delimiter pairs using colors especially in lisp modes.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode
  :config (setq rainbow-delimiters-max-face-count 3)
  :init (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** visual-fill-column
Allows margins to be dynamically resized.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :commands visual-fill-column-mode
  :config
  (setq-default visual-fill-column-center-text nil
                visual-fill-column-width fill-column))
#+END_SRC

*** nlinum-mode
If we're not using Emacs 26+ we need nlinum to support line numbers.

#+BEGIN_SRC emacs-lisp
(unless (boundp 'display-line-numbers)
  (use-package nlinum
    :commands nlinum-mode
    :config
    (setq nlinum-highlight-current-line t)
    (add-hook 'hl-line-mode-hook #'(lambda ()
      (remove-overlays (point-min) (point-max) 'face 'hl-line)))

    (defun bmacs|init-nlinum-width ()
      "Calculate line number column width beforehand (optimization)."
      (setq nlinum--width
            (length (save-excursion (goto-char (point-max))
                                    (format-mode-line "%l")))))
    (add-hook 'nlinum-mode-hook #'bmacs|init-nlinum-width)))


  (use-package nlinum-hl
    :after nlinum
    :config
    ;; With `markdown-fontify-code-blocks-natively' enabled in `markdown-mode',
    ;; line numbers tend to vanish next to code blocks.
    (advice-add #'markdown-fontify-code-block-natively
                :after #'nlinum-hl-do-markdown-fontify-region)

    ;; When using `web-mode's code-folding an entire range of line numbers will
    ;; vanish in the affected area.
    (advice-add #'web-mode-fold-or-unfold :after #'nlinum-hl-do-generic-flush)

    ;; Changing fonts can leave nlinum line numbers in their original size; this
    ;; forces them to resize.
    (advice-add #'set-frame-font :after #'nlinum-hl-flush-all-windows))
#+END_SRC

** Project

*** projectile
Project support anywhere, for any project

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :demand t
  :init
  (setq projectile-cache-file (concat bmacs-cache-dir "projectile.cache")
        projectile-enable-caching t
        projectile-indexing-method 'alien
        projectile-require-project-root nil
        projectile-known-projects-file (concat bmacs-cache-dir "projectile.projects")
        projectile-globally-ignored-files '(".DS_Store" "Icon" "TAGS")
        projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o" ".class"))

  (add-hook 'bmacs-post-init-hook #'projectile-mode)
  :config
  ;; a more generic project root file
  (push ".project" projectile-project-root-files-bottom-up)

  (setq grep-find-ignored-directories '("target" ".ensime_cache" ".fingerprint"))
  (nconc projectile-globally-ignored-directories '("target" ".ensime_cache" ".fingerprint" "project/target"))
  (nconc projectile-other-file-alist '(("css"  . ("scss" "sass" "less" "style"))
                                       ("scss" . ("css"))
                                       ("sass" . ("css"))
                                       ("less" . ("css"))
                                       ("styl" . ("css"))))

  ;; Projectile root-searching functions can cause an infinite loop on TRAMP
  ;; connections, so disable them.
  (defun bmacs--projectile-locate-dominating-file (orig-fn &rest args)
    "Don't traverse the file system if on a remote connection."
    (unless (file-remote-p default-directory)
      (apply orig-fn args)))
  (advice-add #'projectile-locate-dominating-file :around #'bmacs--projectile-locate-dominating-file))

(defun bmacs-project-root ()
  "Get the path to the root of your project.
If STRICT-P, return nil if no project was found, otherwise return
`default-directory'."
  (let (projectile-require-project-root)
    (projectile-project-root)))

#+END_SRC

** Buffers

*** recentf

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :demand t
  :config
  (setq recentf-save-file (concat bmacs-cache-dir "recentf")
      recentf-max-menu-items 0
      recentf-max-saved-items 300)
  (recentf-mode))
#+END_SRC

** Navigation

*** ace-link
Easily select links to open.

#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :demand t
  :config (ace-link-setup-default))
#+END_SRC

*** ace-window
Easily select windows for various actions.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window ace-swap-window ace-delete-window
             ace-select-window ace-delete-other-windows)
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
        aw-scope 'frame
        aw-background t))
#+END_SRC

*** avy
Quickly jump to things

#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands (avy-goto-char-2 avy-goto-line avy-go-word-or-subword-1 avy-goto-char-timer)
  :config
  (setq avy-all-windows 'all-frames
        avy-background t
        avy-timeout-seconds 0.3))
#+END_SRC

*** TODO smart-forward

*** wgrep
Edit grep buffer and save changes

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :commands (wgrep-setup wgrep-change-to-wgrep-mode)
  :config
  (setq wgrep-auto-save-buffer t)
  (map! :map wgrep-mode-map
        (:desc "wgrep mode actions"
         :prefix ","
         :desc "finish edit"                 :n "s" 'wgrep-finish-edit
         :desc "discard edit"                :n "d" 'wgrep-abort-changes
         :desc "exit wgrep"                  :n "x" 'wgrep-exit)))
#+END_SRC


*** dumb-jump
Jump to any definition ... the dumb way!

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :commands (dumb-jump-go dumb-jump-quick-look dumb-jump-go-other-window
             dumb-jump-back dumb-jump-result-follow)
  :config
  (setq dumb-jump-default-project bmacs-emacs-dir
        dumb-jump-aggressive nil
        dumb-jump-use-visible-window nil
        dumb-jump-selector 'ivy))

(add-hook!
  '(imenu-after-jump-hook evil-jumps-post-jump-hook
    counsel-grep-post-action-hook dumb-jump-after-jump-hook)
  #'recenter)

(defun bmacs/jump-definition (&optional other-window)
  "Jump to the definition of the symbol at point using `dumb-jump'"
  (interactive)
  (evil--jumps-push)
  (if other-window
      (dumb-jump-go-other-window)
    (dumb-jump-go)))

(defun bmacs/jump-definition-other-window ()
  (interactive)
  (+jump/definition t))
#+END_SRC

**** TODO Pull over the jump/search online stuff

** Org Mode
It's org-mode ya'll -- TODO: make sure elpa is loaded instead of built in

*** Org

Functions

#+BEGIN_SRC emacs-lisp

(use-package org-plus-contrib
  :quelpa (org-plus-contrib :fetcher git :repo "http://orgmode.org/org-mode.git"))

;; Ensure ELPA org is prioritized above built-in org.
(when-let* ((path (locate-library "org" nil load-path)))
  (setq load-path (delete path load-path))
  (push (file-name-directory path) load-path))

(defun +borg/open-organizer ()
  "Open the default organizer"
  (interactive)
  (find-file +borg-organizer))

(define-minor-mode +org-pretty-mode
  "TODO"
  :init-value nil
  :lighter " *"
  :group 'evil-org
  (setq org-hide-emphasis-markers +org-pretty-mode)
  (org-toggle-pretty-entities)
  (org-with-silent-modifications
   ;; In case the above un-align tables
   (org-table-map-tables 'org-table-align t)))

(defun +borg|realign-table-maybe ()
  "Auto-align table under cursor and re-calculate formulas."
  (when (org-at-table-p)
    (save-excursion
      (quiet! (org-table-recalculate)))))

(defun +borg|update-cookies ()
  "Update counts in headlines (aka \"cookies\")."
  (when (and buffer-file-name (file-exists-p buffer-file-name))
    (org-update-statistics-cookies t)))

 (defun +borg/dwim-at-point ()
  "Do-what-I-mean at point. This includes following timestamp links, aligning
tables, toggling checkboxes/todos, executing babel blocks, previewing latex
fragments, opening links, or refreshing images."
  (interactive)
  (let* ((scroll-pt (window-start))
         (context (org-element-context))
         (type (org-element-type context)))
    (cond
     ((memq type '(planning timestamp))
      (org-follow-timestamp-link))

     ((memq type '(table table-row))
      (if (org-element-property :tblfm (org-element-property :parent context))
          (org-table-recalculate t)
        (org-table-align)))

     ((org-element-property :checkbox (org-element-lineage context '(item) t))
      (let ((match (and (org-at-item-checkbox-p) (match-string 1))))
        (org-toggle-checkbox (if (equal match "[ ]") '(16)))))

     ((and (eq type 'headline)
           (string= "ARCHIVE" (car-safe (org-get-tags))))
      (org-force-cycle-archived))

     ((eq type 'headline)
      (org-todo
       (cond
        ((eq (org-element-property :todo-type context) 'done) 'none)
        ((eq (org-element-property :todo-type context) 'todo) 'done)
        (t 'todo))))

     ((org-element-property :bullet (org-element-lineage context '(item) t))
      (+borg/toggle-checkbox))

     ((eq type 'babel-call)
      (org-babel-lob-execute-maybe))

     ((memq type '(src-block inline-src-block))
      (org-babel-execute-src-block))

     ((memq type '(latex-fragment latex-environment))
      (org-toggle-latex-fragment))

     ((eq type 'link)
      (let ((path (org-element-property :path (org-element-lineage context '(link) t))))
        (if (and path (image-type-from-file-name path))
            (+borg/refresh-inline-images)
          (org-open-at-point))))

     (t (+borg/refresh-inline-images)))
    (set-window-start nil scroll-pt)))

(defun +borg/indent ()
  "Indent the current item (header or item). Otherwise, forward to
`self-insert-command'."
  (interactive)
  (cond ((org-at-item-p)
         (org-indent-item-tree))
        ((org-at-heading-p)
         (ignore-errors (org-demote)))
        ((org-in-src-block-p t)
         (doom/dumb-indent)) ; TODO dumb-indent
        (t
         (call-interactively #'self-insert-command))))

(defun +borg/indent-or-next-field-or-yas-expand ()
  "Depending on the context either a) indent the current line, b) go the next
table field or c) run `yas-expand'."
  (interactive)
  (call-interactively
   (cond ((and (bound-and-true-p yas-minor-mode)
               (yas--templates-for-key-at-point))
          #'yas-expand)
         ((org-at-table-p)
          #'org-table-next-field)
         (t
          #'+borg/indent))))

(defun +borg/dedent ()
  "Dedent the current item (header or item). Otherwise, forward to
`self-insert-command'."
  (interactive)
  (cond ((org-at-item-p)
         (org-list-indent-item-generic
          -1 nil
          (save-excursion
            (when (org-region-active-p)
              (goto-char (region-beginning)))
            (org-list-struct))))
        ((org-at-heading-p)
         (ignore-errors (org-promote)))
        (t
         (call-interactively #'self-insert-command))))

(defun +borg/dedent-or-prev-field ()
  "Depending on the context either dedent the current item or go the previous
table field."
  (interactive)
  (call-interactively
   (if (org-at-table-p)
       #'org-table-previous-field
     #'+borg/dedent)))

(defun +borg/insert-item (direction)
  "Inserts a new heading, table cell or item, depending on the context.
DIRECTION can be 'above or 'below.

I use this instead of `org-insert-item' or `org-insert-heading' which are too
opinionated and perform this simple task incorrectly (e.g. whitespace in the
wrong places)."
  (interactive)
  (let* ((context (org-element-lineage
                   (org-element-context)
                   '(table table-row headline inlinetask item plain-list)
                   t))
         (type (org-element-type context)))
    (cond ((eq type 'item)
           (let ((marker (org-element-property :bullet context))
                 (pad (save-excursion
                        (back-to-indentation)
                        (- (point) (line-beginning-position)))))
             (pcase direction
               ('below
                (goto-char (line-end-position))
                (insert (concat  "\n" (make-string pad ? ) marker)))
               ('above
                (goto-char (line-beginning-position))
                (insert (make-string pad ? ) marker)
                (save-excursion (insert "\n")))))
           (when (org-element-property :checkbox context)
             (insert "[ ] ")))

          ((memq type '(table table-row))
           (pcase direction
             ('below (org-table-insert-row t))
             ('above (+borg/table-prepend-row-or-shift-up))))

          ((memq type '(headline inlinetask plain-list))
           (let* ((subcontext (org-element-context))
                  (level (save-excursion
                           (org-back-to-heading)
                           (org-element-property
                            :level
                            (if (eq (org-element-type subcontext) 'headline)
                                subcontext
                              1)))))
             (pcase direction
               ('below
                (let ((at-eol (= (point) (1- (line-end-position)))))
                  (goto-char (line-end-position))
                  (org-end-of-subtree)
                  (insert (concat "\n"
                                  (when (= level 1)
                                    (if at-eol
                                        (ignore (cl-incf level))
                                      "\n"))
                                  (make-string level ?*)
                                  " "))))
               ('above
                (org-back-to-heading)
                (org-insert-heading)
                (when (= level 1)
                  (save-excursion (evil-open-above 1))
                  (save-excursion (insert "\n")))))
             (when (org-element-property :todo-type context)
               (org-todo 'todo))))

          (t (user-error "Not a valid list, heading or table")))

    (when (bound-and-true-p evil-mode)
      (evil-append-line 1))))

(defun +org-get-property (name &optional _file) ; TODO Add FILE
  "Get a propery from an org file."
  (save-excursion
    (goto-char 1)
    (re-search-forward (format "^#\\+%s:[ \t]*\\([^\n]+\\)" (upcase name)) nil t)
    (buffer-substring-no-properties (match-beginning 1) (match-end 1))))

(defun +borg/refresh-inline-images ()
  "Refresh image previews in the current heading/tree."
  (interactive)
  (if (> (length org-inline-image-overlays) 0)
      (org-remove-inline-images)
    (org-display-inline-images
     t t
     (if (org-before-first-heading-p)
         (line-beginning-position)
       (save-excursion (org-back-to-heading) (point)))
     (if (org-before-first-heading-p)
         (line-end-position)
       (save-excursion (org-end-of-subtree) (point))))))

(defun +borg/toggle-checkbox ()
  "Toggle the presence of a checkbox in the current item."
  (interactive)
  (org-toggle-checkbox '(4)))
#+END_SRC

Configuration

#+BEGIN_SRC emacs-lisp
;; Custom variables
(defvar +borg-dir (expand-file-name "~/org/")
  "The directory where org files are kept.")
(defvaralias 'org-directory '+borg-dir)

(defvar +borg-organizer (concat +borg-dir "organizer.org")
  "The default organizer.")

(use-package toc-org
  :commands toc-org-enable
  :init (add-hook 'org-mode-hook #'toc-org-enable))

;; The standard unicode characters are usually misaligned depending on the font.
;; This bugs me. Personally, markdown #-marks for headlines are more elegant, so
;; we use those.
(use-package org-bullets
  :quelpa (org-bullets :fetcher github :repo "hlissner/org-bullets")
  :commands org-bullets-mode
  :init (add-hook 'org-mode-hook #'org-bullets-mode))


(defun +borg|hook ()
  "Run everytime `org-mode' is enabled."
  (add-hook 'evil-insert-state-exit-hook #'+borg|realign-table-maybe nil t)
  (add-hook 'evil-insert-state-exit-hook #'+borg|update-cookies nil t)
  (+org-evil-mode +1)

  ;; TODO Add filesize checks (possibly too expensive in big org files)
  (add-hook 'before-save-hook #'+borg|update-cookies nil t)

  ;;
  (setq line-spacing 1)
  (visual-line-mode +1)
  (org-indent-mode +1)
  (bmacs|disable-line-numbers)
  (setq-local company-idle-delay nil)

  ;; show-paren-mode causes problems for org-indent-mode, so disable it
  (set (make-local-variable 'show-paren-mode) nil)

  (unless org-agenda-inhibit-startup
    ;; My version of the 'overview' #+STARTUP option: expand first-level
    ;; headings. Expands the first level, but no further.
    (when (eq org-startup-folded t)
      (outline-hide-sublevels 2))

    ;; If saveplace places the point in a folded position, unfold it on load
    (when (outline-invisible-p)
      (ignore-errors
        (save-excursion
          (outline-previous-visible-heading 1)
          (org-show-subtree))))))

(defun +borg|init ()
  "Run once, when org is first loaded."
  (define-minor-mode +org-evil-mode
    "Evil-mode bindings for org-mode."
    :init-value nil
    :lighter " !"
    :keymap (make-sparse-keymap)
    :group 'evil-org)

  (+borg-init-ui)
  (+borg-init-keybinds)
  (+borg-hacks))

;;
(defun +borg-init-ui ()
  "Configures the UI for `org-mode'."
  (setq-default
   org-adapt-indentation nil
   org-agenda-dim-blocked-tasks nil
   org-agenda-files (directory-files +borg-dir t "\\.org$" t)
   org-agenda-inhibit-startup t
   org-agenda-skip-unavailable-files nil
   org-cycle-include-plain-lists t
   org-cycle-separator-lines 1
   org-entities-user '(("flat"  "\\flat" nil "" "" "266D" "♭") ("sharp" "\\sharp" nil "" "" "266F" "♯"))
   org-ellipsis "  "
   ;org-fontify-done-headline t
   org-fontify-quote-and-verse-blocks t
   ;org-fontify-whole-heading-line t
   org-footnote-auto-label 'plain
   org-hidden-keywords nil
   org-hide-emphasis-markers nil
   org-hide-leading-stars t
   org-hide-leading-stars-before-indent-mode t
   org-image-actual-width nil
   org-indent-indentation-per-level 2
   org-indent-mode-turns-on-hiding-stars t
   org-pretty-entities nil
   org-pretty-entities-include-sub-superscripts t
   org-priority-faces `((?a . ,(doom-color 'red))
                        (?b . ,(doom-color 'yellow))
                        (?c . ,(doom-color 'green)))
   org-startup-folded t
   org-startup-indented t
   org-startup-with-inline-images nil
   org-tags-column 0
   org-todo-keywords '((sequence "TODO(t)" "IN-PROGRESS(i)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c)"))
   org-use-sub-superscripts '{}
   outline-blank-line t
   org-log-done 'time

   ;; LaTeX previews are too small and usually render to light backgrounds, so
   ;; this enlargens them and ensures their background (and foreground) match the
   ;; current theme.
   org-format-latex-options (plist-put org-format-latex-options :scale 1.5)
   org-format-latex-options
   (plist-put org-format-latex-options
              :background (face-attribute (or (cadr (assq 'default face-remapping-alist))
                                              'default)
                                          :background nil t)))

  ;; Use ivy/helm if either is available
    (setq-default org-completion-use-ido nil
                  org-outline-path-complete-in-steps nil))

(defun evil-org-eol-call (fun)
  "Go to end of line and call provided function.
FUN function callback"
  (end-of-line)
  (funcall fun)
  (evil-append nil))

(defun +borg-init-keybinds ()
  "Sets up org-mode and evil keybindings. Tries to fix the idiosyncrasies
between the two."
  (map! (:map org-mode-map
          "RET" #'org-return-indent
          "C-j" nil
          "C-k" nil)

        (:map +org-evil-mode-map
          :n "RET" #'+borg/dwim-at-point
          ;; Navigate table cells
          :i  "M-l"   #'+borg/table-next-field
          :i  "M-h"   #'+borg/table-previous-field
          :i  "M-k"   #'+borg/table-previous-row
          :i  "M-j"   #'+borg/table-next-row

          :i  [tab]     #'+borg/indent-or-next-field-or-yas-expand
          :i  [backtab] #'+borg/dedent-or-prev-field

          :nv "j"   #'evil-next-visual-line
          :nv "k"   #'evil-previous-visual-line

          :ni [M-return]   (lambda () (+borg/insert-item 'below))
          :ni [S-M-return] (lambda () (+borg/insert-item 'above))
          :ni [C-return]   (lambda () (+borg/insert-item 'below))
          :ni [S-C-return] (lambda () (+borg/insert-item 'above))

          :ni "M-SPC" #'org-cycle

          :n  "C-j"   #'org-next-visible-heading
          :n  "C-k"   #'org-previous-visible-heading
          :n  "C-S-j"     #'org-forward-heading-same-level
          :n  "C-S-k"     #'org-backward-heading-same-level

          ;; Evil-org
          :niv "M-h" #'org-metaleft
          :niv "M-l" #'org-metaright
          :niv "M-k" #'org-metaup
          :niv "M-j" #'org-metadown
          :niv "M-L" #'org-shiftmetaright
          :niv "M-H" #'org-shiftmetaleft
          :niv "M-K" #'org-shiftmetaup
          :niv "M-J" #'org-shiftmetadown
          :niv "M-o" '(lambda () (interactive)
                        (evil-org-eol-call
                         '(lambda()
                            (org-insert-heading)
                            (org-metaright))))
          :niv "C-t" '(lambda () (interactive)
                        (evil-org-eol-call
                         '(lambda()
                            (org-insert-todo-heading nil)
                            (org-metaright))))
          :niv "M-t" '(lambda () (interactive)
                        (evil-org-eol-call
                         '(lambda()
                            (org-insert-todo-heading nil)
                            (org-metaright))))

          (:localleader
           :n  "RET" #'org-archive-subtree
           :n  "SPC" #'+borg/toggle-checkbox
           :n  "/"   #'org-sparse-tree
           :n  "="   #'org-align-all-tags
           :n  "?"   #'org-tags-view
           :n  "a"   #'org-agenda
           :n  "d"   #'org-time-stamp
           :n  "D"   #'org-deadline
           :n  "e"   #'org-edit-special
           :n  "E"   #'+borg/edit-special-same-window
           :n  "i"   (lambda () (if (and (boundp 'iimage-mode) iimage-mode) (turn-off-iimage-mode) (turn-on-iimage-mode)))
           :n  "n"   (lambda () (if (buffer-narrowed-p) (widen) (org-narrow-to-subtree)))
           :n  "r"   #'org-refile
           :n  "R"   (lambda () (org-metaleft) (org-archive-to-archive-sibling)) ; archive to parent sibling
           :n  "s"   #'org-schedule
           :n  "t"   #'counsel-org-tag
           :v  "t"   (lambda () (evil-ex-normal evil-visual-beginning evil-visual-end "\\t"))
           :n  "T"   #'org-todo
           :n  "v"   #'variable-pitch-mode
           :nv "l"   #'org-insert-link
           :nv "L"   #'org-store-link
           :n  "+"   #'org-timestamp-up-day
           :n  "-"   #'org-timestamp-down-day)

          :n  "<"   #'org-metaleft
          :n  ">"   #'org-metaright
          :v  "<"   (lambda () (org-metaleft)  (evil-visual-restore))
          :v  ">"   (lambda () (org-metaright) (evil-visual-restore))))

  (after! org-agenda
    (map! :map org-agenda-mode-map
          :e "<escape>" #'org-agenda-Quit
          :e "m"   #'org-agenda-month-view
          :e "C-j" #'org-agenda-next-item
          :e "C-k" #'org-agenda-previous-item
          :e "C-n" #'org-agenda-next-item
          :e "C-p" #'org-agenda-previous-item)))

;;
(defun +borg-hacks ()
  "Getting org to behave."
  ;; Don't open separate windows
  (cl-pushnew '(file . find-file) org-link-frame-setup)

  ;; Let OS decide what to do with files when opened
  (setq org-file-apps
        `(("\\.org$" . emacs)
          (t . ,(cond (IS-MAC "open -R \"%s\"")
                      (IS-LINUX "xdg-open \"%s\"")))))

  (defun +borg|remove-occur-highlights ()
    "Remove org occur highlights on ESC in normal mode."
    (when (derived-mode-p 'org-mode)
      (org-remove-occur-highlights)
      t))
  (add-hook '+evil-esc-hook #'+borg|remove-occur-highlights)

  (after! recentf
    ;; Don't clobber recentf with agenda files
    (defun +borg-is-agenda-file (filename)
      (cl-find (file-truename filename) org-agenda-files
               :key #'file-truename
               :test #'equal))
    (add-to-list 'recentf-exclude #'+borg-is-agenda-file)))

(+borg|init)
;(add-hook 'org-load-hook #'+borg|init)
(add-hook 'org-mode-hook #'+borg|hook)
#+END_SRC

*** Babel

#+BEGIN_SRC emacs-lisp
(add-hook 'org-load-hook #'+org-babel|init t)

(defun +org-babel|init ()
  (setq org-src-fontify-natively t      ; make code pretty
        org-src-preserve-indentation t  ; use native major-mode indentation
        org-src-tab-acts-natively t
        org-src-window-setup 'current-window
        org-confirm-babel-evaluate nil) ; you don't need my permission

  (org-babel-do-load-languages
   'org-babel-load-languages
   (mapcar (lambda (sym) (cons sym t))
           '(calc
             css
             emacs-lisp
             haskell
             js
             latex
             ledger
             lilypond
             lisp
             matlab
             plantuml
             python
             restclient ; ob-restclient
             ruby
             rust       ; ob-rust
             shell
             sqlite
             sql-mode   ; ob-sql-mode
             translate  ; ob-translate
             )))

  ;; In a recent update, `org-babel-get-header' was removed from org-mode, which
  ;; is something a fair number of babel plugins use. So until those plugins
  ;; update, this polyfill will do:
  (defun org-babel-get-header (params key &optional others)
    (cl-loop with fn = (if others #'not #'identity)
             for p in params
             if (funcall fn (eq (car p) key))
             collect p))

  ;; I prefer C-c C-c for confirming over the default C-c '
  (map! :map org-src-mode-map "C-c C-c" #'org-edit-src-exit)

  (defun +org|src-mode-remove-header ()
    "Remove header-line with keybinding help; I know the keybinds."
    (when header-line-format
      (setq header-line-format nil)))
  (add-hook 'org-src-mode-hook #'+org|src-mode-remove-header))
#+END_SRC

*** Capture

#+BEGIN_SRC emacs-lisp
(add-hook 'org-load-hook #'+org-capture|init t)

(defun +org-capture|init ()
  "Set up a sane `org-capture' workflow."
  (setq org-capture-templates
        '(
          ("t" "Task" entry
           (file+headline +borg-organizer "Inbox")
           "* TODO %?\nCAPTURED: %t\n\n%i\n")

          ("T" "Quick Task" entry
           (file+headline +borg-organizer "Inbox")
           "* TODO %?\nSCHEDULED: %t\n\n%i\n")

          ("n" "Notes" entry
           (file+headline (concat +borg-dir "notes.org") "Inbox")
           "* %u %?\n%i" :prepend t)
          ))

  (add-hook 'org-capture-mode-hook #'evil-insert-state)

  ;; Allows the Emacs mini-frame (opened from an external shell script to run
  ;; and clean up properly) if the frame is named "org-capture".
  (require 'org-capture)
  (require 'org-protocol)
  (defun +org-capture*init (&rest _)
    "Makes sure the org-capture window is the only window in the frame."
    (when (equal "org-capture" (frame-parameter nil 'name))
      (setq mode-line-format nil)
      (delete-other-windows)))
  (advice-add #'org-capture :after #'+org-capture*init)

  (defun +org-capture|finalize ()
    "Closes the frame once org-capture is done."
    (when (equal "org-capture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'+org-capture|finalize))
#+END_SRC

*** Present

#+BEGIN_SRC emacs-lisp
(defun +doom-present*org-tree-slide-narrow-exclude-header (orig-fn &rest args)
  "TODO"
  (cl-letf (((symbol-function 'org-narrow-to-subtree)
             (lambda () (save-excursion
                     (save-match-data
                       (org-with-limited-levels
                        (narrow-to-region
                         (progn (org-back-to-heading t)
                                (forward-line 1)
                                (point))
                         (progn (org-end-of-subtree t t)
                                (when (and (org-at-heading-p) (not (eobp))) (backward-char 1))
                                (point)))))))))
    (apply orig-fn args)))

;;;###autoload
(defun +org-present|org-tree-prepare-window ()
  "TODO"
  (doom/window-zoom)
  (let ((arg (if org-tree-slide-mode +1 -1)))
    (when (fboundp 'centered-window-mode)
      (centered-window-mode arg))
    (window-divider-mode (* arg -1))
    (doom-hide-modeline-mode arg)
    (+org-pretty-mode arg)
    (cond (org-tree-slide-mode
           (org-indent-mode -1)
           (text-scale-set +org-present-text-scale)
           (ignore-errors (org-toggle-latex-fragment '(4)))
           (set-face-attribute 'org-level-2 nil :height 1.4))
          (t
           (org-indent-mode +1)
           (text-scale-set 0)
           (org-remove-latex-fragment-image-overlays)
           (set-face-attribute 'org-level-2 nil :height 1.0)
           (+org-present|remove-overlays)
           (org-remove-inline-images)))))

(defvar +org-present--overlays nil)
;;;###autoload
(defun +org-present/org-tree-slides ()
  (interactive)
  (unless (derived-mode-p 'org-mode)
    (error "Not in an org buffer"))
  (call-interactively 'org-tree-slide-mode)
  (add-hook 'kill-buffer-hook '+org-present--cleanup-org-tree-slides-mode))

;;;###autoload
(defun +org-present|add-overlays ()
  (add-to-invisibility-spec '(+org-present))
  (save-excursion
    ;; hide org-mode options starting with #+
    (goto-char (point-min))
    (while (re-search-forward "^[[:space:]]*\\(#\\+\\)\\(\\(?:BEGIN\\|END\\|ATTR\\)[^[:space:]]+\\).*" nil t)
      (+org-present--make-invisible
       (match-beginning 1)
       (match-end 0)))
    ;; hide stars in headings
    (goto-char (point-min))
    (while (re-search-forward "^\\(\\*+\\s-\\)" nil t)
      (+org-present--make-invisible (match-beginning 1) (match-end 1)))))

;;;###autoload
(defun +org-present|remove-overlays ()
  (mapc #'delete-overlay +org-present--overlays)
  (remove-from-invisibility-spec '(+org-present)))

;;;###autoload
(defun +org-present|detect-slide ()
  (outline-show-all)
  (if (member "title" (org-get-tags-at))
      (text-scale-set 10)
    (text-scale-set +org-present-text-scale)))

(defun +org-present--cleanup-org-tree-slides-mode ()
  (unless (cl-loop for buf in (doom-buffers-in-mode 'org-mode)
                   if (buffer-local-value 'org-tree-slide-mode buf)
                   return t)
    (org-tree-slide-mode -1)
    (remove-hook 'kill-buffer-hook #'+org-present--cleanup-org-tree-slides-mode)))

(defun +org-present--make-invisible (beg end)
  (let ((overlay (make-overlay beg end)))
    (push overlay +org-present--overlays)
    (overlay-put overlay 'invisible '+org-present)))

(defvar +org-present-text-scale 7
  "The `text-scale-amount' for `org-tree-slide-mode'.")

(add-hook 'org-load-hook #'+org-present|init t)


;;
;; Plugins
;;

(use-package ox-reveal
  :config
  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"
        org-reveal-mathjax t))


(use-package org-tree-slide
  :commands org-tree-slide-mode
  :config
  (org-tree-slide-simple-profile)
  (setq org-tree-slide-skip-outline-level 2
        org-tree-slide-activate-message " "
        org-tree-slide-slide-in-effect t
        org-tree-slide-deactivate-message " "
        org-tree-slide-modeline-display nil)

  (map! :map org-tree-slide-mode-map
        :n [right] #'org-tree-slide-move-next-tree
        :n [left]  #'org-tree-slide-move-previous-tree
        :n "C-n"   #'org-tree-slide-move-next-tree
        :n "C-p"   #'org-tree-slide-move-previous-tree)

  (add-hook! 'org-tree-slide-mode-after-narrow-hook
    #'(+org-present|detect-slide +org-present|add-overlays org-display-inline-images))

  (add-hook 'org-tree-slide-mode-hook #'+org-present|org-tree-prepare-window)
  (advice-add #'org-tree-slide--display-tree-with-narrow
              :around #'+doom-present*org-tree-slide-narrow-exclude-header))


(use-package centered-window-mode
  :commands centered-window-mode
  :config
  (setq cwm-use-vertical-padding t
        cwm-frame-internal-border 110
        cwm-left-fringe-ratio -10
        cwm-centered-window-width 240))


;;
;; Bootstrap
;;

(defun +org-present|init ()
  (require 'ox-reveal)

  (map! :map org-mode-map
        "<f8>" #'+org-present/org-tree-slides
        "<f7>" #'+org-present/next))

#+END_SRC

** Email

Configuration

#+BEGIN_SRC emacs-lisp
(defvar +email-mu4e-mail-path "~/.mail"
  "The directory path of mu's maildir.")

;;
;; Plugins
;;

(use-package mu4e
  :ensure nil
  :commands (mu4e mu4e-compose-new)
  :config
  (setq mu4e-maildir +email-mu4e-mail-path
        mu4e-attachment-dir "~/Downloads"
        mu4e-user-mail-address-list nil
        mu4e-update-interval nil
        mu4e-compose-format-flowed nil ; visual-line-mode + auto-fill upon sending
        mu4e-view-show-addresses t
        mu4e-html2text-command 'mu4e-shr2text
        shr-width 100
        ;; try to show images
        mu4e-view-show-images t
        mu4e-view-image-max-width 800
        ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
        mu4e-sent-messages-behavior 'sent
        ;; for mbsync
        mu4e-change-filenames-when-moving t
        ;; allow for updating mail using 'U' in the main view:
        mu4e-get-mail-command "mbsync-update-fast"
        ;; configuration for sending mail
        message-send-mail-function #'smtpmail-send-it
        smtpmail-stream-type 'ssl
        ;; start with the first (default) context;
        mu4e-context-policy 'pick-first
        ;; compose with the current context, or ask
        mu4e-compose-context-policy 'ask-if-none
        ;; use helm/ivy
        mu4e-completing-read-function #'ivy-completing-read
        ;; close message after sending it
        message-kill-buffer-on-exit t
        ;; no need to ask
        mu4e-confirm-quit nil
        ;; remove 'lists' column
        mu4e-headers-fields
        '((:account . 12)
          (:human-date . 12)
          (:flags . 4)
          (:from . 25)
          (:subject))
        mu4e-bookmarks `(("maildir:/fastmail/INBOX OR maildir:/gmail/INBOX OR maildir:/stream/INBOX" "Inbox" ?i)
                         ("maildir:/fastmail/Drafts OR maildir:/gmail/[Gmail]/.Drafts OR maildir:/stream/[Gmail]/.Drafts" "Drafts" ?d)
                         ("flag:unread AND maildir:/fastmail/INBOX OR maildir:/gmail/INBOX OR maildir:/stream/INBOX" "Unread messages" ?u)
                         ("flag:flagged" "Starred messages" ?s)
                         ("date:today..now" "Today's messages" ?t)
                         ("date:7d..now" "Last 7 days" ?w)
                         ("mime:image/*" "Messages with images" ?p)))

  (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

  ;; Add a column to display what email account the email belongs to.
  (add-to-list 'mu4e-header-info-custom
               '(:account
                 :name "Account"
                 :shortname "Account"
                 :help "Which account this email belongs to"
                 :function
                 (lambda (msg)
                   (let ((maildir (mu4e-message-field msg :maildir)))
                     (format "%s" (substring maildir 1 (string-match-p "/" maildir 1)))))))



;; Change refile to an 'A'
(setq mu4e-marks (assq-delete-all 'refile mu4e-marks))
(push '(refile
        :char ("A" . "▶")
        :prompt "archive"
        :dyn-target (lambda (target msg) (mu4e-get-refile-folder msg))
        :action (lambda (docid msg target) (mu4e~proc-move docid
                                                      (mu4e~mark-check-target target) "-N")))
      mu4e-marks)

;; Special handling for fastmail, don't add +T and move to trash
;; Gmail is configured to automatically add deleted emails to the trash
(setq mu4e-marks (assq-delete-all 'delete mu4e-marks))
(push '(delete
        :char ("D" . "❌")
        :prompt "Delete"
        :show-target (lambda (target) "delete")
        :action (lambda (docid msg target)
                  (let ((maildir (mu4e-message-field msg :maildir)))
                    (cond ((string-prefix-p "/fastmail" maildir)
                           (mu4e~proc-move docid (mu4e-get-trash-folder msg) "-N"))
                          ((or (string-prefix-p "/gmail" maildir) (string-prefix-p "/stream" maildir))
                           (shell-command (format "expunge-email-id %s" (mu4e-message-field msg :message-id))))
                          (true (mu4e~proc-remove docid))))))
      mu4e-marks)

  ;; Refresh the current view after marks are executed
  (defun +email*refresh (&rest _) (mu4e-headers-rerun-search))
  (advice-add #'mu4e-mark-execute-all :after #'+email*refresh)

  (add-hook 'mu4e-compose-mode-hook (lambda ()
                                      (setq-local fill-column 120)
                                      (auto-fill-mode -1)
                                      (visual-line-mode)
                                      (visual-fill-column-mode)))

(add-hook 'mu4e-view-mode-hook (lambda ()
                                    (setq-local fill-column 120)
                                    (visual-line-mode)
                                    (visual-fill-column-mode)))

  ; (when (featurep! :feature spellcheck) TODO
  ;   (add-hook 'mu4e-compose-mode-hook #'flyspell-mode))

  ;; Wrap text in messages
  (add-hook! 'mu4e-view-mode-hook
    (setq-local truncate-lines nil))

  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))

  (after! evil
    (cl-loop for str in '((mu4e-main-mode . normal)
                          (mu4e-view-mode . normal)
                          (mu4e-headers-mode . normal)
                          (mu4e-compose-mode . normal)
                          (mu4e~update-mail-mode . normal))
             do (evil-set-initial-state (car str) (cdr str)))

    (setq mu4e-view-mode-map (make-sparse-keymap)
          ;; mu4e-compose-mode-map (make-sparse-keymap)
          mu4e-headers-mode-map (make-sparse-keymap)
          mu4e-main-mode-map (make-sparse-keymap))

    (map! (:map (mu4e-main-mode-map mu4e-view-mode-map)
            :localleader
            :n "s" #'mu4e-context-switch
            :n "b" #'mu4e-headers-search-bookmark
            :n "B" #'mu4e-headers-search-bookmark-edit
            :n "j" #'mu4e~headers-jump-to-maildir
            :n "/" #'mu4e-headers-search)

          (:map (mu4e-headers-mode-map mu4e-view-mode-map)
            :localleader
            :n "f" #'mu4e-compose-forward
            :n "r" #'mu4e-compose-reply
            :n "c" #'mu4e-compose-new
            :n "e" #'mu4e-compose-edit)

          (:map mu4e-main-mode-map
            :n "J"   #'mu4e~headers-jump-to-maildir
            :n "s"   #'mu4e-headers-search
            :n "q"   #'mu4e-quit
            :n "u"   #'mu4e-update-index
            :n "U"   #'mu4e-update-mail-and-index
            :n "J"   #'mu4e~headers-jump-to-maildir
            :n "c"   #'+email/compose
            :n "C"   #'+email/compose
            :n "b"   #'mu4e-headers-search-bookmark)

          (:map mu4e-headers-mode-map
            :n "q"   #'mu4e~headers-quit-buffer
            :n "r"   #'mu4e-compose-reply
            :n "c"   #'mu4e-compose-edit
            :n "s"   #'mu4e-headers-search-edit
            :n "S"   #'mu4e-headers-search-narrow
            :n "RET" #'mu4e-headers-view-message
            :n "u"   #'mu4e-headers-mark-for-unmark
            :n "U"   #'mu4e-mark-unmark-all
            :n "v"   #'evil-visual-line
            :nv "d"  #'mu4e-headers-mark-for-delete
            :nv "a"  #'mu4e-headers-mark-for-refile
            :n "x"   #'mu4e-mark-execute-all

            :n "]]"  #'mu4e-headers-next-unread
            :n "[["  #'mu4e-headers-prev-unread

            (:localleader
              :n "s" 'mu4e-headers-change-sorting
              :n "t" 'mu4e-headers-toggle-threading
              :n "r" 'mu4e-headers-toggle-include-related
              :n "a" #'mu4e-headers-action
              :n "%" #'mu4e-headers-mark-pattern
              :n "t" #'mu4e-headers-mark-subthread
              :n "T" #'mu4e-headers-mark-thread
              :n "/" #'mu4e-headers-search-narrow))

          (:map mu4e-view-mode-map
            :n "q" #'mu4e~view-quit-buffer
            :n "r" #'mu4e-compose-reply
            :n "c" #'mu4e-compose-edit
            :n "o" #'mu4e-view-go-to-url
            :n "d"  #'mu4e-view-mark-for-delete
            :n "a"  #'mu4e-view-mark-for-refile

            :n "<M-Left>"  #'mu4e-view-headers-prev
            :n "<M-Right>" #'mu4e-view-headers-next
            :n "[m" #'mu4e-view-headers-prev
            :n "]m" #'mu4e-view-headers-next
            :n "[u" #'mu4e-view-headers-prev-unread
            :n "]u" #'mu4e-view-headers-next-unread

            (:localleader
              :n "%" #'mu4e-view-mark-pattern
              :n "t" #'mu4e-view-mark-subthread
              :n "T" #'mu4e-view-mark-thread
              :n "a" #'mu4e-view-action
              :n "o" #'mu4e-view-open-attachment
              :n "d" #'mu4e-view-mark-for-trash
              :n "r" #'mu4e-view-mark-for-refile
              :n "m" #'mu4e-view-mark-for-move))

          (:map mu4e~update-mail-mode-map
            :n "q" #'mu4e-interrupt-update-mail))))


(use-package mu4e-maildirs-extension
  :after mu4e
  :config (mu4e-maildirs-extension-load))


(defun bmail-refile-folder-function (msg)
  "Set the refile folder for MSG."
  (let ((maildir (mu4e-message-field msg :maildir)))
    (cond
     ((string-prefix-p "/fastmail" maildir)
      "/fastmail/Archive")
     ((string-prefix-p "/gmail" maildir)
      "/gmail/[Gmail]/All Mail")
     ((string-prefix-p "/stream" maildir)
      "/stream/[Gmail]/All Mail")
     (t nil))))

(defun bmail-trash-folder-function (msg)
  "Set the trash folder for MSG."
  (let ((maildir (mu4e-message-field msg :maildir)))
    (cond
     ((string-prefix-p "/fastmail" maildir)
      "/fastmail/Trash")
     ((string-prefix-p "/gmail" maildir)
      "/gmail/[Gmail]/.Trash")
     ((string-prefix-p "/stream" maildir)
      "/stream/[Gmail]/.Trash")
     (t nil))))

(defun email-signature (address)
  (+gilbertw1/file-as-string
   (expand-file-name (concat "~/.signatures/" address))))

(after! mu4e
  (setq mu4e-refile-folder #'bmail-refile-folder-function
        mu4e-trash-folder #'bmail-trash-folder-function
        smtpmail-debug-info t
        smtpmail-stream-type 'ssl
        smtpmail-default-smtp-server "smtp.fastmail.com"
        smtpmail-smtp-server "smtp.fastmail.com"
        smtpmail-smtp-user "gilbertw1@fastmail.com"
        smtpmail-smtp-service 465)

  (setq mu4e-contexts
      `(,(make-mu4e-context
          :name "fastmail"
          :match-func (lambda (msg) (when msg
                                 (string-prefix-p "/fastmail" (mu4e-message-field msg :maildir))))
          :vars '((mu4e-sent-folder          . "/fastmail/Sent")
                  (mu4e-drafts-folder        . "/fastmail/Drafts")
                  (smtpmail-smtp-user        . "gilbertw1@fastmail.com")
                  (smtpmail-smtp-server      . "smtp.fastmail.com")
                  (smtpmail-stream-type      . ssl)
                  (smtpmail-smtp-service     . 465)
                  (user-mail-address         . "bryan@bryan.sh")
                  (user-full-name            . "Bryan Gilbert")
                  (mu4e-compose-signature    . (email-signature "bryan@bryan.sh"))))
        ,(make-mu4e-context
          :name "gmail"
          :match-func (lambda (msg) (when msg
                                 (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
          :vars '((mu4e-sent-folder          . "/gmail/[Gmail]/.Sent Mail")
                  (mu4e-drafts-folder        . "/gmail/[Gmail]/.Drafts")
                  (smtpmail-smtp-user        . "gilbertw1@gmail.com")
                  (smtpmail-smtp-server      . "smtp.gmail.com")
                  (smtpmail-stream-type      . starttls)
                  (smtpmail-smtp-service     . 587)
                  (user-mail-address         . "gilbertw1@gmail.com")
                  (user-full-name            . "Bryan Gilbert")
                  (mu4e-compose-signature    . (email-signature "gilbertw1@gmail.com"))))
        ,(make-mu4e-context
          :name "stream"
          :match-func (lambda (msg) (when msg
                                 (string-prefix-p "/stream" (mu4e-message-field msg :maildir))))
          :vars '((mu4e-sent-folder          . "/stream/[Gmail]/.Sent Mail")
                  (mu4e-drafts-folder        . "/stream/[Gmail]/.Drafts")
                  (smtpmail-smtp-user        . "bryan@stre.am")
                  (smtpmail-smtp-server      . "smtp.gmail.com")
                  (smtpmail-stream-type      . starttls)
                  (smtpmail-smtp-service     . 587)
                  (user-mail-address         . "bryan@stream.live")
                  (user-full-name            . "Bryan Gilbert")
                  (mu4e-compose-signature    . (email-signature "bryan@stream.live")))))))

#+END_SRC

** Tools

*** Restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :commands restclient-mode
  :mode ("\\.\\(http\\|rest\\)$" . restclient-mode)
  :config
  ;;(set! :popup "*HTTP Response*" :size 30 :select t :noesc t :autokill t) TODO
  (map! :mode restclient-mode
        :n [M-return] 'restclient-http-send-current
        :localleader
        :desc "Execute HTTP request"     :n "e" 'restclient-http-send-current
        :desc "Execute raw HTTP request" :n "E" 'restclient-http-send-current-raw
        :desc "Copy curl command"        :n "c" 'restclient-copy-curl-command))


(use-package company-restclient
  :after restclient
  :config
  (add-hook 'restclient-mode #'(lambda ()
                                 (setq-local company-backends '(restclient-mode company-restclient)))))
#+END_SRC

*** Dash Docs
Quick and awesome documentation lookup

#+BEGIN_SRC emacs-lisp
(use-package counsel-dash
  :after counsel
  :config
  (setq counsel-dash-docsets-path (concat bmacs-cache-dir "docsets"))
  ;; Language Hooks
  (add-hook 'emacs-lisp-mode-hook (lambda () (setq-local counsel-dash-docsets '("Emacs Lisp"))))
  (add-hook 'scala-mode-hook (lambda () (setq-local counsel-dash-docsets '("Scala" "Akka" "Play_Scala" "Java"))))
  (add-hook 'java-mode-hook (lambda () (setq-local counsel-dash-docsets '("Java" "Play_Java"))))
  (add-hook 'rust-mode-hook (lambda () (setq-local counsel-dash-docsets '("Rust"))))
  (add-hook 'clojure-mode-hook (lambda () (setq-local counsel-dash-docsets '("Clojure"))))
  (add-hook 'haskell-mode-hook (lambda () (setq-local counsel-dash-docsets '("Haskell"))))
  (add-hook 'sh-mode-hook (lambda () (setq-local counsel-dash-docsets '("Bash"))))
  (add-hook 'c-mode-hook (lambda () (setq-local counsel-dash-docsets '("C"))))
  (add-hook 'c++-mode-hook (lambda () (setq-local counsel-dash-docsets '("C++"))))
  (add-hook 'js2-mode-hook (lambda () (setq-local counsel-dash-docsets '("Javascript"))))
  (add-hook 'js-mode-hook (lambda () (setq-local counsel-dash-docsets '("Javascript"))))
  (add-hook 'html-mode-hook (lambda () (setq-local counsel-dash-docsets '("HTML" "Javascript"))))
  (add-hook 'python-mode-hook (lambda () (setq-local counsel-dash-docsets '("Python 3")))))
#+END_SRC

*** Dired
Directories in Emacs

#+BEGIN_SRC emacs-lisp
(setq ;; Always copy/delete recursively
      dired-recursive-copies  'always
      dired-recursive-deletes 'top
      ;; Auto refresh dired, but be quiet about it
      global-auto-revert-non-file-buffers t
      auto-revert-verbose nil
      ;; files
      image-dired-dir (concat bmacs-cache-dir "image-dired/")
      image-dired-db-file (concat image-dired-dir "image-dired/db.el")
      image-dired-gallery-dir (concat image-dired-dir "gallery/")
      image-dired-temp-image-file (concat image-dired-dir "temp-image")
      image-dired-temp-rotate-image-file (concat image-dired-dir "temp-rotate-image"))

(after! dired
  (map! :map dired-mode-map
        :n "c" #'find-file
        :n "d" #'dired-do-delete
        :n "r" #'dired-do-rename))

(use-package dired-k
  :after dired
  :config
  (setq dired-k-style 'git)

  (defun +dired*dired-k-highlight (orig-fn &rest args)
    "Butt out if the requested directory is remote (i.e. through tramp)."
    (unless (file-remote-p default-directory)
      (apply orig-fn args)))
  (advice-add #'dired-k--highlight :around #'+dired*dired-k-highlight)

  (add-hook 'dired-initial-position-hook #'dired-k)
  (add-hook 'dired-after-readin-hook #'dired-k-no-revert))


(use-package stripe-buffer
  :commands stripe-buffer-mode
  :init (add-hook 'dired-mode-hook #'stripe-buffer-mode))

#+END_SRC

*** EShell
A terminal by Emacs for Emacs!

#+BEGIN_SRC emacs-lisp
(defun +eshell/evil-append ()
  (interactive)
  (goto-char eshell-last-output-end)
  (call-interactively #'evil-append-line))

(defun +eshell/evil-append-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (+eshell/evil-append)
    (call-interactively #'evil-append)))

(defun +eshell/evil-prepend ()
  (interactive)
  (goto-char eshell-last-output-end)
  (call-interactively #'evil-insert))

(defun +eshell/evil-prepend-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (+eshell/evil-prepend)
    (call-interactively #'evil-insert)))

(defun +eshell/evil-replace-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (user-error "Cannot edit read-only region")
    (call-interactively #'evil-replace)))

(defun +eshell/evil-replace-state-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (user-error "Cannot edit read-only region")
    (call-interactively #'evil-replace-state)))

(defun +eshell/evil-change ()
  (interactive)
  (when (+eshell--outside-prompt-p)
    (goto-char eshell-last-output-end))
  (call-interactively #'evil-change))

(defun +eshell/evil-change-line ()
  (interactive)
  (when (+eshell--outside-prompt-p)
    (goto-char eshell-last-output-end))
  (call-interactively #'evil-change-line))

(use-package eshell ; built-in
  :commands eshell-mode
  :init
  (setq eshell-directory-name (concat bmacs-cache-dir "/eshell")
        eshell-scroll-to-bottom-on-input 'all
        eshell-scroll-to-bottom-on-output 'all
        eshell-buffer-shorthand t
        eshell-kill-processes-on-exit t
        ;; em-prompt
        eshell-prompt-regexp "^.* λ "
        eshell-prompt-function #'+eshell-prompt
        ;; em-glob
        eshell-glob-case-insensitive t
        eshell-error-if-no-glob t
        ;; em-alias
        eshell-aliases-file (concat bmacs-local-dir ".eshell-aliases"))

  :config
  (add-to-list 'evil-insert-state-modes 'eshell-mode)

  (after! em-term
    ;; Visual commands require a proper terminal. Eshell can't handle that, so it
    ;; delegates these commands to a term buffer.
    (nconc eshell-visual-commands '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim"))
    (setq eshell-visual-subcommands '(("git" "log" "l" "diff" "show"))))

  (defun +eshell|init-keymap ()
    "Setup eshell keybindings. This must be done in a hook because eshell-mode
redefines its keys every time `eshell-mode' is enabled."
    (map! :map eshell-mode-map
          :n "i"        #'+eshell/evil-prepend-maybe
          :n "I"        #'+eshell/evil-prepend
          :n "a"        #'+eshell/evil-append-maybe
          :n "A"        #'+eshell/evil-append
          :n "r"        #'+eshell/evil-replace-maybe
          :n "R"        #'+eshell/evil-replace-state-maybe
          :n "c"        #'+eshell/evil-change
          :n "C"        #'+eshell/evil-change-line
          :i [tab]      #'eshell-pcomplete
          :i "SPC"      #'self-insert-command
          :i "C-u"      #'eshell-kill-input
          :i "C-a"      #'eshell-bol
          :i "C-d"      #'+eshell/quit-or-delete-char
          :i "C-k"      #'kill-line
          :i "C-p"      #'eshell-previous-input
          :i "<up>"     #'eshell-previous-input
          :i "C-n"      #'eshell-next-input
          :i "<down>"   #'eshell-next-input
          :m "<return>" #'+eshell/evil-append
          ;; BMACS - needed to actually send input and use shell
          :i "<return>" #'eshell-send-input
          :n [remap evil-window-split]     #'+eshell/split
          :n [remap evil-window-vsplit]    #'+eshell/vsplit
          :n [remap evil-record-macro]     #'eshell-life-is-too-much
          [remap kill-this-buffer] #'eshell-life-is-too-much
          [remap +workspace/close-window-or-workspace] #'eshell-life-is-too-much))
  (add-hook 'eshell-mode-hook #'+eshell|init-keymap)

  (add-hook! eshell-mode
    (add-hook 'evil-insert-state-exit-hook  #'hl-line-mode nil t)
    (add-hook 'evil-insert-state-entry-hook (lambda () (hl-line-mode -1)) nil t))

  ;; Aliases
  (setq eshell-command-aliases-list
        '(("q"   "exit")
          ("l"   "ls -1")
          ("ll"  "ls -l")
          ("la"  "ls -la")
          ("g"   "hub")
          ("gs"  "hub status --short ."))))

#+END_SRC

*** Imenu
TODO - I really have no idea

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :commands (ido-imenu-anywhere ivy-imenu-anywhere helm-imenu-anywhere)
  :config (setq imenu-anywhere-delimiter ": "))


(use-package imenu-list
  :commands imenu-list-minor-mode
  :config
  (setq imenu-list-focus-after-activation t))
#+END_SRC

*** NeoTree

#+BEGIN_SRC emacs-lisp
(defun +neotree/toggle ()
  "Toggle the neotree window."
  (interactive)
  (let ((path buffer-file-name)
        (project-root (bmacs-project-root)))
    (require 'neotree)
    (cond ((and (neo-global--window-exists-p)
                (get-buffer-window neo-buffer-name t))
           (neotree-find path project-root))
          ((not (and (neo-global--window-exists-p)
                     (equal (file-truename (neo-global--with-buffer neo-buffer--start-node))
                            (file-truename project-root))))
           (neotree-dir project-root)
           (neotree-find path project-root))
          (t (neotree-find path project-root)))))

(defun +neotree/collapse-or-up ()
  "Collapse an expanded directory node or go to the parent node."
  (interactive)
  (when-let (node (neo-buffer--get-filename-current-line))
    (if (file-directory-p node)
        (if (neo-buffer--expanded-node-p node)
            (+neotree/collapse)
          (neotree-select-up-node))
      (neotree-select-up-node))))

(defun +neotree/collapse ()
  "Collapse a neotree node."
  (interactive)
  (when-let (node (neo-buffer--get-filename-current-line))
    (when (file-directory-p node)
      (neo-buffer--set-expand node nil)
      (neo-buffer--refresh t))
    (when neo-auto-indent-point
      (neo-point-auto-indent))))

(defun +neotree/neo-hide-on-enter (type path arg)
  (if (or (and (eq +neotree/neotree-opening-file t)
               (equal type 'file))
          (and (eq +neotree/neotree-entering-dired t)
               (equal type 'directory)))
      (neotree-hide))
  (setq +neotree/neotree-opening-file nil
        +neotree/neotree-entering-dired nil))

(defun +neotree/before-neobuffer-execute (arg0 &optional file-fn dir-fn &rest args)
  (when (eq dir-fn 'neo-open-dired)
    (setq +neotree/neotree-entering-dired t))
  (when (or (eq file-fn 'neo-open-file)
            (eq file-fn 'neo-open-file-vertical-split)
            (eq file-fn 'neo-open-file-horizontal-split))
    (setq +neotree/neotree-opening-file t)))

(defun +neotree/expand-or-open ()
  "Expand or open a neotree node."
  (interactive)
  (when-let (node (neo-buffer--get-filename-current-line))
    (cond ((file-directory-p node)
           (neo-buffer--set-expand node t)
           (neo-buffer--refresh t)
           (when neo-auto-indent-point
             (forward-line)
             (neo-point-auto-indent)))
          (t
           (call-interactively #'neotree-enter)))))

(use-package neotree
  :commands (neotree-show
             neotree-hide
             neotree-toggle
             neotree-dir
             neotree-find
             neo-global--with-buffer
             neo-global--window-exists-p)
  :config
  (setq neo-create-file-auto-open nil
        neo-auto-indent-point nil
        neo-autorefresh nil
        neo-mode-line-type 'none
        neo-window-width 32
        neo-show-updir-line nil
        neo-theme 'nerd ; fallback
        neo-banner-message nil
        neo-confirm-create-file #'off-p
        neo-confirm-create-directory #'off-p
        neo-show-hidden-files nil
        neo-keymap-style 'concise
        neo-hidden-regexp-list
        '(;; vcs folders
          "^\\.\\(git\\|hg\\|svn\\)$"
          ;; compiled files
          "\\.\\(pyc\\|o\\|elc\\|lock\\|css.map\\)$"
          ;; generated files, caches or local pkgs
          "^\\(node_modules\\|vendor\\|.\\(project\\|cask\\|yardoc\\|sass-cache\\)\\)$"
          ;; org-mode folders
          "^\\.\\(sync\\|export\\|attach\\)$"
          "~$"
          "^#.*#$"))

  (when (bound-and-true-p winner-mode)
    (push neo-buffer-name winner-boring-buffers))

  ;; BMACS - Hide neotree on enter file
  (defvar +neotree/neotree-opening-file nil)
  (defvar +neotree/neotree-entering-dired nil)
  (add-hook 'neo-enter-hook #'+neotree/neo-hide-on-enter)
  (advice-add 'neo-buffer--execute :before #'+neotree/before-neobuffer-execute))

(setq doom-neotree-file-icons t)
#+END_SRC

*** TODO Term

** Programming Languages

*** Assembly
The language of the machine!

#+BEGIN_SRC emacs-lisp
(use-package mips-mode :mode "\\.mips$")

(use-package haxor-mode :mode "\\.hax$")

(use-package nasm-mode :commands nasm-mode)
#+END_SRC

*** CC
Can you hear the C? -- TODO: Pair this down to just basic C/C++ support ... too complex

#+BEGIN_SRC emacs-lisp
  (defun +cc*align-lambda-arglist (orig-fun &rest args)
    "Improve indentation of continued C++11 lambda function opened as argument."
    (if (and (eq major-mode 'c++-mode)
             (ignore-errors
               (save-excursion
                 (goto-char (c-langelem-pos langelem))
                 ;; Detect "[...](" or "[...]{". preceded by "," or "(",
                 ;;   and with unclosed brace.
                 (looking-at-p ".*[(,][ \t]*\\[[^]]*\\][ \t]*[({][^}]*$"))))
        0 ; no additional indent
      (apply orig-fun args)))

  (defun +cc/autoclose->-maybe ()
    "For some reason smartparens won't autoskip >'s, this hack does."
    (interactive)
    (if (save-excursion
          (backward-char)
          (looking-at-p "[^ \t]>"))
        (forward-char)
      (call-interactively #'self-insert-command)))

  (defun +cc-sp-point-is-template-p (id action context)
    "Return t if point is in the right place for C++ angle-brackets."
    (and (sp-in-code-p id action context)
         (sp-point-after-word-p id action context)))

  (defun +cc-sp-point-after-include-p (id action context)
    "Return t if point is in an #include."
    (and (sp-in-code-p id action context)
         (save-excursion
           (goto-char (line-beginning-position))
           (looking-at-p "[ 	]*#include[^<]+"))))

  (defun +cc-c-lineup-inclass (_langelem)
    "Indent privacy keywords at same level as class properties."
    (if (memq major-mode '(c-mode c++-mode))
        (let ((inclass (assq 'inclass c-syntactic-context)))
          (save-excursion
            (goto-char (c-langelem-pos inclass))
            (if (or (looking-at "struct")
                    (looking-at "typedef struct"))
                '+
              '++)))
      '+))


  ;;
  ;; Hooks
  ;;

  (defun +cc|fontify-constants ()
    "Better fontification for preprocessor constants"
    (font-lock-add-keywords
     nil '(("\\<[A-Z]*_[A-Z_]+\\>" . font-lock-constant-face)
           ("\\<[A-Z]\\{3,\\}\\>"  . font-lock-constant-face))
     t))

  (use-package cc-mode
    :commands (c-mode c++-mode objc-mode java-mode)
    :mode ("\\.mm" . objc-mode)
    :preface
    (defun +cc-c++-header-file-p ()
      (and buffer-file-name
           (equal (file-name-extension buffer-file-name) "h")
           (or (file-exists-p (expand-file-name
                               (concat (file-name-sans-extension buffer-file-name)
                                       ".cpp")))
               (when-let (file (car-safe (projectile-get-other-files
                                          buffer-file-name
                                          (projectile-current-project-files))))
                 (equal (file-name-extension file) "cpp")))))

    (defun +cc-objc-header-file-p ()
      (and buffer-file-name
           (equal (file-name-extension buffer-file-name) "h")
           (re-search-forward "@\\<interface\\>" magic-mode-regexp-match-limit t)))

    (push (cons #'+cc-c++-header-file-p  'c++-mode)  magic-mode-alist)
    (push (cons #'+cc-objc-header-file-p 'objc-mode) magic-mode-alist)

    :init
    (setq-default c-basic-offset tab-width)

    :config
    ;(set! :electric '(c-mode c++-mode objc-mode java-mode)
    ;      :chars '(?\n ?\}))
    ;(set! :company-backend
    ;      '(c-mode c++-mode objc-mode)
    ;      '(company-irony-c-headers company-irony))

    ;;; Style/formatting
    ;; C/C++ style settings
    (c-toggle-electric-state -1)
    (c-toggle-auto-newline -1)
    (c-set-offset 'substatement-open '0) ; don't indent brackets
    (c-set-offset 'inline-open       '+)
    (c-set-offset 'block-open        '+)
    (c-set-offset 'brace-list-open   '+)
    (c-set-offset 'case-label        '+)
    (c-set-offset 'access-label      '-)
    (c-set-offset 'arglist-intro     '+)
    (c-set-offset 'arglist-close     '0)
    ;; Indent privacy keywords at same level as class properties
    ;; (c-set-offset 'inclass #'+cc-c-lineup-inclass)

    ;;; Better fontification (also see `modern-cpp-font-lock')
    (add-hook 'c-mode-common-hook #'rainbow-delimiters-mode)
    (add-hook! (c-mode c++-mode) #'highlight-numbers-mode)
    (add-hook! (c-mode c++-mode) #'+cc|fontify-constants)

    ;; Improve indentation of inline lambdas in C++11
    (advice-add #'c-lineup-arglist :around #'+cc*align-lambda-arglist)

    ;;; Keybindings
    ;; Completely disable electric keys because it interferes with smartparens and
    ;; custom bindings. We'll do this ourselves.
    (setq c-tab-always-indent nil
          c-electric-flag nil)
    (dolist (key '("#" "{" "}" "/" "*" ";" "," ":" "(" ")"))
      (define-key c-mode-base-map key nil))
    ;; Smartparens and cc-mode both try to autoclose angle-brackets intelligently.
    ;; The result isn't very intelligent (causes redundant characters), so just do
    ;; it ourselves.
    (map! :map c++-mode-map
          "<" nil
          :i ">" #'+cc/autoclose->-maybe)

    ;; ...and leave it to smartparens
    (sp-with-modes '(c-mode c++-mode objc-mode java-mode)
      (sp-local-pair "<" ">" :when '(+cc-sp-point-is-template-p +cc-sp-point-after-include-p))
      (sp-local-pair "/*" "*/" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
      ;; Doxygen blocks
      (sp-local-pair "/**" "*/" :post-handlers '(("||\n[i]" "RET") ("||\n[i]" "SPC")))
      (sp-local-pair "/*!" "*/" :post-handlers '(("||\n[i]" "RET") ("[d-1]< | " "SPC")))))


  (use-package modern-cpp-font-lock
    :commands modern-c++-font-lock-mode
    :init (add-hook 'c++-mode-hook #'modern-c++-font-lock-mode))


  (use-package irony
    :after cc-mode
    :commands irony-install-server
    :preface
    (setq irony-server-install-prefix (concat bmacs-etc-dir "irony-server/"))
    :init
    (add-hook! (c-mode c++-mode objc-mode) #'irony-mode)
    :config
    (unless (file-directory-p irony-server-install-prefix)
      (warn "irony-mode: server isn't installed; run M-x irony-install-server")))

  (use-package irony-eldoc
    :after irony
    :config (add-hook 'irony-mode-hook #'irony-eldoc))

  (use-package flycheck-irony
    :after irony
    :config
    (add-hook 'irony-mode-hook #'flycheck-mode)
    (flycheck-irony-setup))


  ;;
  ;; Tools
  ;;

  (use-package disaster :commands disaster)


  ;;
  ;; Major modes
  ;;

  (use-package cmake-mode
    :mode "CMakeLists\\.txt$")
    ; :config
    ;(set! :company-backend 'cmake-mode '(company-cmake company-yasnippet)))

  (use-package cuda-mode :mode "\\.cuh?$")

  (use-package opencl-mode :mode "\\.cl$")

  (use-package demangle-mode
    :commands demangle-mode
    :init (add-hook 'llvm-mode-hook #'demangle-mode))

  (use-package glsl-mode
    :mode "\\.glsl$"
    :mode "\\.vert$"
    :mode "\\.frag$"
    :mode "\\.geom$")


  ;;
  ;; Plugins
  ;;

  (use-package company-irony :after irony)

  (use-package company-irony-c-headers :after company-irony)

  (use-package company-glsl
    :after glsl-mode)
    ;; :config
    ;; (if (executable-find "glslangValidator")
    ;;     (warn "glsl-mode: couldn't find glslangValidator, disabling company-glsl")
    ;;   (set! :company-backend 'glsl-mode '(company-glsl))))
#+END_SRC

*** Clojure
Lisp, but java.

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :mode "\\.clj$")

(use-package cider
  :commands (cider-jack-in cider-mode)
  :config
  (setq nrepl-hide-special-buffers t))
#+END_SRC

*** CSharp
Java, but Microsoft

#+BEGIN_SRC emacs-lisp
(use-package csharp-mode :mode "\\.cs$")

(use-package omnisharp
  :after csharp-mode
  :preface
  (setq omnisharp-auto-complete-want-documentation nil
        omnisharp-server-executable-path (concat bmacs-local-dir "OmniSharp.exe"))
  :config
  (if (file-exists-p omnisharp-server-executable-path)
      (add-hook! csharp-mode #'(eldoc-mode flycheck-mode omnisharp-mode))
    (warn "csharp-mode: omnisharp server isn't installed, completion won't work"))

  ;(set! :company-backend 'csharp-mode '(company-omnisharp))

  (map! :map omnisharp-mode-map
        :m "gd" #'omnisharp-go-to-definition

        (:localleader
         :n "b" #'omnisharp-recompile

         ; (:prefix "r"
         ;   :n "i"  #'omnisharp-fix-code-issue-at-point
         ;   :n "u"  #'omnisharp-fix-usings
         ;   :n "r"  #'omnisharp-rename
         ;   :n "a"  #'omnisharp-show-last-auto-complete-result
         ;   :n "o"  #'omnisharp-show-overloads-at-point)

         (:prefix "f"
           :n "u"  #'omnisharp-find-usages
           :n "i"  #'omnisharp-find-implementations
           :n "f"  #'omnisharp-navigate-to-current-file-member
           :n "m"  #'omnisharp-navigate-to-solution-member
           :n "M"  #'omnisharp-navigate-to-solution-file-then-file-member
           :n "F"  #'omnisharp-navigate-to-solution-file
           :n "r"  #'omnisharp-navigate-to-region
           :n "ti" #'omnisharp-current-type-information
           :n "td" #'omnisharp-current-type-documentation)

         (:prefix "t"
           :n "r" (lambda () (omnisharp-unit-test "fixture"))
           :n "s" (lambda () (omnisharp-unit-test "single"))
           :n "a" (lambda () (omnisharp-unit-test "all"))))))


(use-package shader-mode :mode "\\.shader$") ; unity shaders
#+END_SRC

*** Data + Config Formats
Various data and configuration formats

#+BEGIN_SRC emacs-lisp
  (push '("/sxhkdrc" . conf-mode) auto-mode-alist)

  (use-package nxml-mode
    :ensure nil
    :mode "\\.plist$")
    ;; :config
    ;; (set! :company-backend 'nxml-mode '(company-nxml company-yasnippet)))


  (use-package toml-mode :mode "\\.toml$")


  (use-package yaml-mode :mode "\\.ya?ml$")


  (use-package json-mode
    :mode "\\.js\\(on\\|[hl]int\\(rc\\)?\\)$")
    ;; :config
    ;; (set! :electric 'json-mode :chars '(?\n ?: ?{ ?})))


  (use-package vimrc-mode
    :mode "/\\.?g?vimrc$"
    :mode "\\.vim$"
    :mode "\\.?vimperatorrc$"
    :mode "\\.vimp$")


  (use-package dockerfile-mode
    :mode "/Dockerfile$")


  ;; For ROM hacking or debugging
  (use-package hexl
    :mode ("\\.hex$" . hexl-mode)
    :mode ("\\.nes$" . hexl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :mode "\\.exs?$")
#+END_SRC

*** Elm
Reactive javascriptish like?

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :mode "\\.elm$"
  :config
  (add-hook 'elm-mode-hook #'(flycheck-mode rainbow-delimiters-mode))
  (setq elm-format-on-save t))


(use-package flycheck-elm
  :after elm-mode
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
#+END_SRC

*** Emacs-lisp
The language that runs on the Emacs interpreter

#+BEGIN_SRC emacs-lisp

  (use-package elisp-mode ; built-in
    :ensure nil
    :mode ("/Cask$" . emacs-lisp-mode)
    :config
    (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
    (add-hook 'emacs-lisp-mode-hook #'(lambda ()
      (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)))
    (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'emacs-lisp-mode-hook #'highlight-quoted-mode)
    (add-hook 'emacs-lisp-mode-hook #'highlight-numbers-mode)
    (add-hook 'emacs-lisp-mode-hook #'+emacs-lisp|extra-fontification)
    (add-hook 'emacs-lisp-mode-hook #'+emacs-lisp|init-imenu)
    (add-hook 'emacs-lisp-mode-hook #'+emacs-lisp|init-flycheck)

    ;;
    (defun +emacs-lisp|extra-fontification ()
      "Display lambda as a smybol and fontify doom module functions."
      (font-lock-add-keywords
       nil `(;; Display "lambda" as λ
             ("(\\(lambda\\)" (1 (ignore (compose-region (match-beginning 1) (match-end 1) ?λ #'decompose-region))))
             ;; Highlight doom/module functions
             ("\\(^\\|\\s-\\|,\\)(\\(\\(doom\\|\\+\\)[^) ]+\\)[) \n]" (2 font-lock-keyword-face)))))

    (defun +emacs-lisp|init-imenu ()
      "Improve imenu support with better expression regexps and Doom-specific forms."
      (setq imenu-generic-expression
            '(("Evil Commands" "^\\s-*(evil-define-\\(?:command\\|operator\\|motion\\) +\\(\\_<[^ ()\n]+\\_>\\)" 1)
              ("Package" "^\\s-*(\\(?:def-\\)?package! +\\(\\_<[^ ()\n]+\\_>\\)" 1)
              ("Settings" "^\\s-*(def-setting! +\\([^ ()\n]+\\)" 1)
              ("Modelines" "^\\s-*(def-modeline! +\\([^ ()\n]+\\)" 1)
              ("Modeline Segments" "^\\s-*(def-modeline-segment! +\\([^ ()\n]+\\)" 1)
              ("Advice" "^\\s-*(def\\(?:\\(?:ine-\\)?advice\\))")
              ("Modes" "^\\s-*(define-\\(?:global\\(?:ized\\)?-minor\\|generic\\|minor\\)-mode +\\([^ ()\n]+\\)" 1)
              ("Macros" "^\\s-*(\\(?:cl-\\)?def\\(?:ine-compile-macro\\|macro\\) +\\([^ )\n]+\\)" 1)
              ("Inline Functions" "\\s-*(\\(?:cl-\\)?defsubst +\\([^ )\n]+\\)" 1)
              ("Functions" "^\\s-*(\\(?:cl-\\)?def\\(?:un\\|un\\*\\|method\\|generic\\|-memoized!\\) +\\([^ ,)\n]+\\)" 1)
              ("Variables" "^\\s-*(\\(def\\(?:c\\(?:onst\\(?:ant\\)?\\|ustom\\)\\|ine-symbol-macro\\|parameter\\)\\)\\s-+\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)" 2)
              ("Variables" "^\\s-*(defvar\\(?:-local\\)?\\s-+\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)[[:space:]\n]+[^)]" 1)
              ("Types" "^\\s-*(\\(cl-def\\(?:struct\\|type\\)\\|def\\(?:class\\|face\\|group\\|ine-\\(?:condition\\|error\\|widget\\)\\|package\\|struct\\|t\\(?:\\(?:hem\\|yp\\)e\\)\\)\\)\\s-+'?\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)" 2))))

    (defun +emacs-lisp|init-flycheck ()
      "Initialize flycheck-mode if not in emacs.d."
      (when (and buffer-file-name
                 (not (file-in-directory-p buffer-file-name bmacs-emacs-dir)))
        (flycheck-mode +1))))

  ;;
  ;; Plugins
  ;;

  (use-package highlight-quoted
    :commands highlight-quoted-mode)

  (use-package slime
    :config
    (setq inferior-lisp-program "clisp")
    (require 'slime-fuzzy))

  (use-package macrostep
    :commands macrostep-expand
    :config
    (map! :map macrostep-keymap
          :n "RET"    #'macrostep-expand
          :n "e"      #'macrostep-expand
          :n "u"      #'macrostep-collapse
          :n "c"      #'macrostep-collapse

          :n "TAB"    #'macrostep-next-macro
          :n "n"      #'macrostep-next-macro
          :n "J"      #'macrostep-next-macro

          :n "S-TAB"  #'macrostep-prev-macro
          :n "K"      #'macrostep-prev-macro
          :n "p"      #'macrostep-prev-macro

          :n "q"      #'macrostep-collapse-all
          :n "C"      #'macrostep-collapse-all)
    ;; `evil-normalize-keymaps' seems to be required for macrostep or it won't
    ;; apply for the very first invocation
    (add-hook 'macrostep-mode-hook #'evil-normalize-keymaps))

  (use-package flycheck-cask
    :commands flycheck-cask-setup
    :init
    (add-hook! 'emacs-lisp-hook
      (add-hook 'flycheck-mode-hook #'flycheck-cask-setup nil t)))

  (use-package overseer
    :commands overseer-test)
    ;; :init
    ;; (set! :popup '("*overseer*" :size 12)))
#+END_SRC

*** Go
Go by Google

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go$"
    :interpreter "go"
    :config
    (add-hook 'go-mode-hook #'flycheck-mode)

    (setq gofmt-command "goimports")
    (if (not (executable-find "goimports"))
        (warn "go-mode: couldn't find goimports; no code formatting/fixed imports on save")
      (add-hook go-mode #'(add-hook 'before-save-hook #'gofmt-before-save nil t))))

  (use-package go-eldoc
    :after go-mode
    :commands go-eldoc-setup
    :config (add-hook 'go-mode-hook #'go-eldoc-setup))

  (use-package go-guru
    :commands (go-guru-describe go-guru-freevars go-guru-implements go-guru-peers
               go-guru-referrers go-guru-definition go-guru-pointsto
               go-guru-callstack go-guru-whicherrs go-guru-callers go-guru-callees
               go-guru-expand-region)
    :config
    (unless (executable-find "guru")
      (warn "go-mode: couldn't find guru, refactoring commands won't work")))

  (use-package gorepl-mode
    :commands (gorepl-run gorepl-run-load-current-file)
    :config
    (unless (executable-find "gore")
      (warn "go-mode: couldn't find gore, REPL support disabled")))

  (use-package company-go
    :init (setq command-go-gocode-command "gocode")
    :after go-mode)
    ;; :config
    ;; (if (executable-find command-go-gocode-command)
    ;;     (set! :company-backend 'go-mode '(company-go))
    ;;   (warn "go-mode: couldn't find gocode, code completion won't work")))
#+END_SRC

*** Haskell
Lazy lazy functional programming

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :mode "\\.hs$"
  :mode ("\\.ghci$" . ghci-script-mode)
  :mode ("\\.cabal$" . haskell-cabal-mode)
  :interpreter (("runghc" . haskell-mode)
                ("runhaskell" . haskell-mode))
  :config
  (load "haskell-mode-autoloads" nil t)
  (add-hook 'haskell-mode-hook #'hindent-mode)
  (add-hook 'haskell-mode-hook (lambda () (ghc-init)))
  (add-hook 'haskell-mode-hook #'structured-haskell-mode)

  (push ".hi" completion-ignored-extensions)

  (custom-set-variables '(company-ghc-show-info t))

  (autoload 'switch-to-haskell "inf-haskell" nil t))
  ; (after! inf-haskell
  ;   (map! :map inferior-haskell-mode-map "ESC ESC" #'doom/popup-close))) ; TODO

(use-package ghc
  :commands (ghc-init ghc-debug))

(use-package company-ghc
  :commands (company-ghc))

(use-package shm
  :commands (structured-haskell-mode))

(use-package dante
  :after haskell-mode
  :init
  (add-hook 'haskell-mode-hook #'(dante-mode interactive-haskell-mode))
  :config
  (unless (executable-find "cabal")
    (warn "haskell-mode: couldn't find cabal")
    (remove-hook 'haskell-mode-hook #'dante-mode))

  (add-hook 'dante-mode-hook #'flycheck-mode))

(use-package company-ghc
  :after haskell-mode
  :init
  (add-hook 'haskell-mode-hook #'ghc-comp-init)
  :config
  (if (executable-find "ghc-mod")
      (add-hook! haskell-mode (setq-local company-backends '(company-ghc)))
    (warn "haskell-mode: couldn't find ghc-mode")
    (remove-hook 'haskell-mode-hook #'ghc-comp-init))

  (setq company-ghc-show-info 'oneline))
#+END_SRC

*** Hy
Python? Lisp? WTF?

#+BEGIN_SRC emacs-lisp
(use-package hy-mode
  :mode "\\.hy$")
#+END_SRC

*** Java / Android / Groovy

#+BEGIN_SRC emacs-lisp

  (use-package meghanada
    :commands meghanada-mode
    :config
    (setq meghanada-server-install-dir (concat bmacs-etc-dir "meghanada-server/")
          meghanada-use-company t
          meghanada-use-flycheck t
          meghanada-use-eldoc t
          meghanada-use-auto-start nil)

    (add-hook 'java-mode-hook #'(rainbow-delimiters-mode eldoc-mode))

    ;; Setup on first use
    (meghanada-install-server)
    (if (file-exists-p (meghanada--locate-server-jar))
        (add-hook! 'java-mode-hook #'(meghanada-mode flycheck-mode))
      (warn "java-mode: meghanada-server not installed, java-mode will run with reduced functionality")))

  (use-package android-mode
    :commands android-mode
    :init
    (add-hook! (java-mode groovy-mode nxml-mode) #'+java|android-mode-maybe))
    ;; :config
    ;; (set! :yas-minor-mode 'android-mode)
    ;; (set! :company-dict-minor-mode 'android-mode))

  (use-package groovy-mode
    :mode "\\.g\\(radle\\|roovy\\)$")
    ;; :config
    ;; (set! :eval 'groovy-mode "groovy"))

  (add-hook 'java-mode-hook (lambda ()
                              (setq c-basic-offset 4
                                    tab-width 4
                                    indent-tabs-mode nil)))
#+END_SRC

*** Javascript
Gross

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :mode "\\.js$"
  :interpreter "node"
  :config
  (setq js2-skip-preprocessor-directives t
        js2-highlight-external-variables nil
        js2-mode-show-parse-errors nil)

  (add-hook! 'js2-mode-hook
    #'(flycheck-mode highlight-indentation-mode rainbow-delimiters-mode))

  (sp-with-modes '(js2-mode rjsx-mode)
    (sp-local-pair "/* " " */" :post-handlers '(("| " "SPC")))))

(use-package nodejs-repl :commands nodejs-repl)

(use-package js2-refactor
  :commands
  (js2r-extract-function js2r-extract-method js2r-introduce-parameter
   js2r-localize-parameter js2r-expand-object js2r-contract-object
   js2r-expand-function js2r-contract-function js2r-expand-array
   js2r-contract-array js2r-wrap-buffer-in-iife js2r-inject-global-in-iife
   js2r-add-to-globals-annotation js2r-extract-var js2r-inline-var
   js2r-rename-var js2r-var-to-this js2r-arguments-to-object js2r-ternary-to-if
   js2r-split-var-declaration js2r-split-string js2r-unwrap js2r-log-this
   js2r-debug-this js2r-forward-slurp js2r-forward-barf))

(use-package tern
  :commands tern-mode
  :init (add-hook 'js2-mode-hook #'tern-mode))

(use-package rjsx-mode
  :commands rjsx-mode
  :mode "\\.jsx$"
  :mode "components/.+\\.js$"
  :init
  (defun +javascript-jsx-file-p ()
    (and buffer-file-name
         (equal (file-name-extension buffer-file-name) "js")
         (re-search-forward "\\(^\\s-*import React\\|\\( from \\|require(\\)[\"']react\\)"
                            magic-mode-regexp-match-limit t)
         (progn (goto-char (match-beginning 1))
                (not (sp-point-in-string-or-comment)))))

  (push (cons #'+javascript-jsx-file-p 'rjsx-mode) magic-mode-alist)

  :config
  (add-hook! rjsx-mode
    ;; jshint doesn't really know how to deal with jsx
    (push 'javascript-jshint flycheck-disabled-checkers)))


(use-package coffee-mode
  :mode "\\.coffee$"
  :init (setq coffee-indent-like-python-mode t))


(use-package web-beautify
  :commands web-beautify-js)
#+END_SRC

*** Julia
Math stuff.

#+BEGIN_SRC emacs-lisp
(use-package julia-mode
  :mode "\\.jl$"
  :interpreter "julia"
  :config
  ;; Borrow matlab.el's fontification of math operators
  ;; From <https://ogbe.net/emacsconfig.html>
  (font-lock-add-keywords
   'julia-mode
   `((,(let ((OR "\\|"))
         (concat "\\(" ;; stolen `matlab.el' operators first
                 "[<>!]=?" OR
                 "\\.[/*^']" OR
                 "==" OR
                 "=>" OR
                 "\\<xor\\>" OR
                 "[-+*\\/^&|$]=?" OR ;; this has to come before next (updating operators)
                 "[-!^&|*+\\/~:]" OR
                 ;; more extra julia operators follow
                 "[%$]" OR
                 ;; bitwise operators
                 ">>>" OR ">>" OR "<<" OR
                 ">>>=" OR ">>" OR "<<" OR
                 ;; comparison
                 "[<>!]=?" OR
                 "\\)"))
      1 font-lock-type-face))))
#+END_SRC

*** Lua

#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :mode "\\.lua$"
  :interpreter "lua"
  :init
  (add-hook 'lua-mode-hook #'flycheck-mode)
  :config
  ;; sp's lua-specific rules are obnoxious, so we disable them
  (setq sp-pairs (delete (assq 'lua-mode sp-pairs) sp-pairs)))

(use-package company-lua
  :after lua-mode)

(use-package moonscript
  :mode ("\\.moon$" . moonscript-mode))
#+END_SRC

*** Markdown
It's not org-mode, but it'll do in a pinch

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode "/README$"
  :mode "\\.m\\(d\\|arkdown\\)$"
  :mode ("/README\\.md$" . gfm-mode)
  :init
  (setq markdown-enable-wiki-links t
        markdown-enable-math t
        markdown-italic-underscore t
        markdown-asymmetric-header t
        markdown-make-gfm-checkboxes-buttons t
        markdown-gfm-additional-languages '("sh")
        markdown-fontify-code-blocks-natively t
        markdown-hide-urls nil) ; trigger with `markdown-toggle-url-hiding'

  :config
  (add-hook! markdown-mode
    (auto-fill-mode +1)
    (setq line-spacing 2
          fill-column 100))

  (map! (:map markdown-mode-map
          [remap find-file-at-point] #'markdown-follow-thing-at-point
          "M-*"      #'markdown-insert-list-item
          "M-b"      #'markdown-insert-bold
          "M-i"      #'markdown-insert-italic
          "M-`"      #'+markdown/insert-del
          :m "gj"    #'markdown-next-visible-heading
          :m "gk"    #'markdown-previous-visible-heading
          ;; Assumes you have a markdown renderer plugin in chrome
          :n "M-r"   #'browse-url-of-file
          ;; TODO: Make context sensitive
          :m "]h"    #'markdown-next-visible-heading
          :m "[h"    #'markdown-previous-visible-heading
          :m "[p"    #'markdown-promote
          :m "]p"    #'markdown-demote
          :m "[l"    #'markdown-next-link
          :m "]l"    #'markdown-previous-link
          :i "M--"   #'markdown-insert-hr

          (:localleader
            :nv "o" #'markdown-open
            :nv "b" #'markdown-preview
            (:prefix "i"
              :nv "t" #'markdown-toc-generate-toc
              :nv "i" #'markdown-insert-image
              :nv "l" #'markdown-insert-link)))))


(use-package markdown-toc
  :commands markdown-toc-generate-toc)
#+END_SRC

*** OCaml
OCaml ... He doesn't scare me at all

#+BEGIN_SRC emacs-lisp
(use-package tuareg
  :mode ("\\.ml[4ilpy]?$" . tuareg-mode))

(use-package merlin
  :after tuareg
  :config
  (add-hook 'tuareg-mode-hook #'merlin-mode))
#+END_SRC

*** Perl
Is perl still a thing?

#+BEGIN_SRC emacs-lisp
(add-hook 'perl-mode-hook #'flycheck-mode)

(use-package perl6-mode)
;  :init (require 'perl6-detect))

(use-package flycheck-perl6
  :after perl6-mode
  :config (add-hook 'perl6-mode-hook #'flycheck-mode))
#+END_SRC

*** Php
The language of CEO's

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :mode ("\\.php[s345]?$" "\\.inc$")
  :interpreter "php"
  :config
  (add-hook 'php-mode-hook
    #'(ac-php-core-eldoc-setup flycheck-mode))

  (setq php-template-compatibility nil)

  ;; default is 10; this optimizes `smartparens' performance, but limits sp
  ;; pairs to 6 characters.
  (add-hook 'php-mode-hook (setq-local sp-max-pair-length 6))

  (sp-with-modes '(php-mode)
    (sp-local-pair "/* "    "*/" :post-handlers '(("||\n[i] " "RET") ("| " "SPC")))
    (sp-local-pair "<? "    " ?>")
    (sp-local-pair "<?php " " ?>")
    (sp-local-pair "<?="    " ?>")
    (sp-local-pair "<?"    "?>"   :when '(("RET")) :post-handlers '("||\n[i]"))
    (sp-local-pair "<?php" "?>"   :when '(("RET")) :post-handlers '("||\n[i]")))

  (map! :map php-mode-map
        :localleader
        (:prefix "r"
          :n "cv" #'php-refactor--convert-local-to-instance-variable
          :n "u"  #'php-refactor--optimize-use
          :v "xm" #'php-refactor--extract-method
          :n "rv" #'php-refactor--rename-local-variable)
        (:prefix "t"
          :n "r"  #'phpunit-current-project
          :n "a"  #'phpunit-current-class
          :n "s"  #'phpunit-current-test)))

(use-package php-refactor-mode
  :commands php-refactor-mode
  :init (add-hook 'php-mode-hook #'php-refactor-mode))

(use-package phpunit
  :commands (phpunit-current-test phpunit-current-class phpunit-current-project))

(use-package php-boris :commands php-boris)

(use-package company-php
  :commands (company-ac-php-backend ac-php-remake-tags ac-php-remake-tags-all ac-php-core-eldoc-setup)
  :config
  (unless (executable-find "phpctags")
    (warn "php-mode: phpctags isn't installed, auto-completion will be gimped"))

  (setq ac-php-tags-path (concat bmacs-cache-dir "ac-php/")))
#+END_SRC

*** Plant Uml



Simple uml syntax

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :mode "\\.p\\(lant\\)?uml$"
  :config
  (setq plantuml-jar-path (concat bmacs-etc-dir "plantuml.jar"))

  (unless (executable-find "java")
    (warn "plantuml-mode: can't find java, preview disabled."))
  (unless (file-exists-p plantuml-jar-path)
    (warn "plantuml-mode: can't find plantuml.jar; run M-x +plantuml/install.")))

(use-package flycheck-plantuml
  :after plantuml-mode
  :config (flycheck-plantuml-setup))
#+END_SRC

*** Play Framework
Play framework routes support

#+BEGIN_SRC emacs-lisp
(use-package play-routes-mode
  :mode "/routes$")
#+END_SRC

*** Purescript

#+BEGIN_SRC emacs-lisp
(use-package purescript-mode
  :mode "\\.purs$"
  :config
  (add-hook 'purescript-mode-hook
    #'(flycheck-mode purescript-indentation-mode rainbow-delimiters-mode))

  (load "purescript-mode-autoloads" nil t))

(use-package psc-ide
  :after purescript-mode
  :config
  (add-hook 'purescript-mode-hook #'psc-ide-mode))

#+END_SRC

*** Python
Hey guys, it's python!

#+BEGIN_SRC emacs-lisp
(defvar +python-pyenv-root nil
  "The path to pyenv's root directory. This is automatically set when `python'
is loaded.")

(defvar +python-pyenv-versions nil
  "Available versions of python in pyenv.")

(defvar-local +python-current-version nil
  "The currently active pyenv version.")

;;
;; Plugins
;;

(use-package python
  :commands python-mode
  :init
  (setq python-environment-directory bmacs-cache-dir
        python-indent-guess-indent-offset-verbose nil
        python-shell-interpreter "python")

  :config
  (add-hook 'python-mode-hook #'(flycheck-mode highlight-numbers-mode))

  (when (executable-find "ipython")
    (setq python-shell-interpreter "ipython"
          python-shell-interpreter-args "-i --simple-prompt --no-color-info"
          python-shell-prompt-regexp "In \\[[0-9]+\\]: "
          python-shell-prompt-block-regexp "\\.\\.\\.\\.: "
          python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
          python-shell-completion-setup-code
          "from IPython.core.completerlib import module_completion"
          python-shell-completion-string-code
          "';'.join(get_ipython().Completer.all_completions('''%s'''))\n"))

  ;; Version management with pyenv
  (defun +python|add-version-to-modeline ()
    "Add version string to the major mode in the modeline."
    (setq mode-name
          (if +python-current-version
              (format "Python %s" +python-current-version)
            "Python")))
  (add-hook 'python-mode-hook #'+python|add-version-to-modeline)

  (if (not (executable-find "pyenv"))
      (setq +python-current-version (string-trim (shell-command-to-string "python --version 2>&1 | cut -d' ' -f2")))
    (setq +python-pyenv-root     (string-trim (shell-command-to-string "pyenv root"))
          +python-pyenv-versions (split-string (shell-command-to-string "pyenv versions --bare") "\n" t))

    (defun +python|detect-pyenv-version ()
      "Detect the pyenv version for the current project and set the relevant
environment variables."
      (when-let (version-str (shell-command-to-string "python --version 2>&1 | cut -d' ' -f2"))
        (setq version-str (string-trim version-str)
              +python-current-version version-str)
        (let ((pyenv-current-path (concat +python-pyenv-root "/versions/" version-str)))
          (when (file-directory-p pyenv-current-path)
            (setq pythonic-environment pyenv-current-path)))
        (when (member version-str +python-pyenv-versions)
          (setenv "PYENV_VERSION" version-str))))
    (add-hook 'python-mode-hook #'+python|detect-pyenv-version))

  (define-key python-mode-map (kbd "DEL") nil) ; interferes with smartparens
  (sp-with-modes 'python-mode
    (sp-local-pair "'" nil :unless '(sp-point-before-word-p sp-point-after-word-p sp-point-before-same-p))))


(use-package anaconda-mode
  :after python
  :init
  (add-hook 'python-mode-hook #'anaconda-mode)
  (add-hook 'anaconda-mode-hook #'anaconda-eldoc-mode)
  (setq anaconda-mode-installation-directory (concat bmacs-etc-dir "anaconda/")
        anaconda-mode-eldoc-as-single-line t))

(use-package company-anaconda
  :after anaconda-mode
  :config
  (map! :map python-mode-map
        :localleader
        :prefix "f"
        :nv "d" #'anaconda-mode-find-definitions
        :nv "h" #'anaconda-mode-show-doc
        :nv "a" #'anaconda-mode-find-assignments
        :nv "f" #'anaconda-mode-find-file
        :nv "u" #'anaconda-mode-find-references))


(use-package pip-requirements
  :mode ("/requirements.txt$" . pip-requirements-mode))
#+END_SRC

*** Ruby

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :mode ("\\.rb$" "\\.rake$" "\\.gemspec$" "\\.?pryrc$"
         "/\\(Gem\\|Cap\\|Vagrant\\|Rake\\|Pod\\|Puppet\\|Berks\\)file$")
  :interpreter "ruby"
  :init
  (add-hook 'ruby-mode-hook #'flycheck-mode)
  :config
  (setq ruby-deep-indent-paren t)
  ;; Don't interfere with my custom RET behavior
  (define-key ruby-mode-map [?\n] nil)

  ;; Version management with rbenv
  (defun +ruby|add-version-to-modeline ()
    "Add version string to the major mode in the modeline."
    (setq mode-name
          (if +python-current-version
              (format "Ruby %s" +ruby-current-version)
            "Ruby")))
  (add-hook 'ruby-mode-hook #'+ruby|add-version-to-modeline)

  (if (not (executable-find "rbenv"))
      (setq +ruby-current-version (string-trim (shell-command-to-string "ruby --version 2>&1 | cut -d' ' -f2")))
    (setq +ruby-rbenv-versions (split-string (shell-command-to-string "rbenv versions --bare") "\n" t))

    (defun +ruby|detect-rbenv-version ()
      "Detect the rbenv version for the current project and set the relevant
environment variables."
      (when-let (version-str (shell-command-to-string "ruby --version 2>&1 | cut -d' ' -f2"))
        (setq version-str (string-trim version-str)
              +ruby-current-version version-str)
        (when (member version-str +ruby-rbenv-versions)
          (setenv "RBENV_VERSION" version-str))))
    (add-hook 'ruby-mode-hook #'+ruby|detect-rbenv-version)))

  ; (map! :map ruby-mode-map
  ;       (:localleader
  ;       (:prefix "r"
  ;        :nv "b"  #'ruby-toggle-block
  ;        :nv "ec" #'ruby-refactor-extract-constant
  ;        :nv "el" #'ruby-refactor-extract-to-let
  ;        :nv "em" #'ruby-refactor-extract-to-method
  ;        :nv "ev" #'ruby-refactor-extract-local-variable
  ;        :nv "ad" #'ruby-refactor-add-parameter
  ;        :nv "cc" #'ruby-refactor-convert-post-conditional))))
#+END_SRC

*** Rust
The future!

#+BEGIN_SRC emacs-lisp
(defvar +rust-src-dir (concat bmacs-etc-dir "rust/")
  "The path to Rust source library. Required by racer.")

(use-package rust-mode
  :mode "\\.rs$")

(use-package racer
  :after rust-mode
  :preface
  :init
  (add-hook! 'rust-mode-hook #'(racer-mode eldoc-mode flycheck-rust-setup))
  :config

  (map! :map rust-mode-map
        :m "gd" #'racer-find-definition
        :localleader
        :desc "Racer Describe"        :n "d" #'racer-describe
        :desc "Racer find definition" :n "D" #'racer-find-definition)

  (unless (file-exists-p racer-cmd)
    (warn "rust-mode: racer binary can't be found; auto-completion is disabled")))

(use-package company-racer
  :after racer
  :config
  (add-hook 'rust-mode-hook #'(lambda ()
                                (setq-local company-backends '(company-racer)))))

(use-package flycheck-rust
  :after rust-mode
  :config (add-hook 'rust-mode-hook #'flycheck-mode))
#+END_SRC

*** Scala
The best the JVM's got to offer

#+BEGIN_SRC emacs-lisp


(use-package scala-mode
  :mode "\\.s\\(cala\\|bt\\)$"
  :config
  (setq scala-indent:align-parameters t)
  (map! :mode scala-mode
        :niv "TAB" 'ensime-company-complete-or-indent
        :localleader
        :desc "Start ensime"             :n "s" #'ensime
        :desc "Shutdown ensime"          :n "x" #'ensime-shutdown
        :desc "Sbt command"              :n "c" #'sbt-command
        :desc "Goto next error"          :n "e" #'next-error
        :desc "Show errors at point"     :n "E" #'ensime-print-errors-at-point))

(use-package sbt-mode :after scala-mode)

(use-package ensime
  :after scala-mode
  :commands (ensime ensime-mode ensime-scala-mode-hook)
  :config
  (add-hook 'scala-mode #'(lambda ()
                            (setq-local company-backends '(ensime-company company-yasnippet))))

  (setq ensime-startup-snapshot-notification nil
        ensime-startup-notification nil
        ensime-eldoc-hints nil
        ensime-completion-style nil)

  (add-hook 'scala-mode-hook #'ensime-mode)
  (add-hook 'ensime-mode-hook #'eldoc-mode)

  ;; Fix void-variable imenu-auto-rescan error caused by `ensime--setup-imenu'
  ;; trying to make imenu variables buffer local before imenu is loaded.
  (require 'imenu))
#+END_SRC

*** Shell
Ghetto shell scripting

#+BEGIN_SRC emacs-lisp
(defun +sh--match-variables-in-quotes (limit)
  "Search for variables in double-quoted strings bounded by LIMIT."
  (with-syntax-table sh-mode-syntax-table
    (let (res)
      (while
          (and (setq res
                     (re-search-forward
                      "\\(\\$\\)\\({.+?}\\|\\<.+?\\>\\)"
                      limit t))
               (not (eq (nth 3 (syntax-ppss)) ?\"))))
      res)))

;;;###autoload
(defun +sh--match-command-subst-in-quotes (limit)
  "Search for variables in double-quoted strings bounded by LIMIT."
  (with-syntax-table sh-mode-syntax-table
    (let (res)
      (while
          (and (setq res
                     (re-search-forward "\\(\\$(.+?)\\|`.+?`\\)"
                                        limit t))
               (not (eq (nth 3 (syntax-ppss)) ?\"))))
      res)))

(defvar +sh-builtin-keywords
  '("sudo" "echo" "ls" "sleep" "tee" "cd" "cat")
  "A list of common shell commands and keywords to be fontified especially in
`sh-mode'.")

(use-package sh-script ; built-in
  :mode ("\\.zsh$"   . sh-mode)
  :mode ("\\.zunit$" . sh-mode)
  :mode ("/bspwmrc$" . sh-mode)
  :init
  (add-hook! sh-mode #'(flycheck-mode highlight-numbers-mode))
  :config
  ;(set! :electric 'sh-mode :words '("else" "elif" "fi" "done" "then" "do" "esac" ";;")) TODO
  (setq sh-indent-after-continuation 'always)

  ;; 1. Fontifies variables in double quotes
  ;; 2. Fontify command substitution in double quotes
  ;; 3. Fontify built-in/common commands (see `+sh-builtin-keywords')
  (font-lock-add-keywords
   'sh-mode `((+sh--match-variables-in-quotes
               (1 'default prepend)
               (2 'font-lock-variable-name-face prepend))
              (+sh--match-command-subst-in-quotes
               (0 'sh-quoted-exec prepend))
              (,(concat "^\\s-*" (regexp-opt +sh-builtin-keywords 'words))
               (0 'font-lock-builtin-face t))))

  ;; autoclose backticks
  (sp-local-pair 'sh-mode "`" nil :unless '(sp-point-before-word-p sp-point-before-same-p))

  ;; sh-mode has file extensions checks for other shells, but not zsh, so...
  (defun +sh|detect-zsh ()
    (when (or (and buffer-file-name
                   (string-match-p "\\.zsh\\'" buffer-file-name))
              (save-excursion
                (goto-char (point-min))
                (looking-at-p "^#!.+zsh[$\\s-]")))
      (sh-set-shell "zsh")))
  (add-hook 'sh-mode-hook #'+sh|detect-zsh))


(use-package company-shell
  :after sh-script
  :config
  (add-hook 'sh-mode-hook #'(lambda ()
                              (setq-local company-backends '(company-shell company-files))))
  (setq company-shell-delete-duplicates t))

#+END_SRC


*** Swift
Get Scwhifty!

#+BEGIN_SRC emacs-lisp
(use-package swift-mode
  :mode "\\.swift$"
  :init
  (add-hook 'swift-mode-hook #'flycheck-mode)
  :config
  (cl-pushnew 'swift flycheck-checkers))

(use-package company-sourcekit
  :after swift-mode
  :config
  (add-hook 'swift-mode-hook #'(lambda ()
                                 (setq-local company-backends '(company-sourcekit company-yasnippet)))))
#+END_SRC

*** Typescript

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :mode "\\.ts$"
  :init
  (add-hook 'typescript-mode-hook #'rainbow-delimiters-mode))


(use-package tide
  :after typescript-mode
  :config
  (add-hook 'typescript-mode-hook #'(lambda ()
                                      (setq-local company-backends '(company-tide))))

  (setq tide-format-options
        '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t
          :placeOpenBraceOnNewLineForFunctions nil))

  (defun +typescript|init-tide ()
    (when (or (eq major-mode 'typescript-mode)
              (and (eq major-mode 'web-mode)
                   buffer-file-name
                   (equal (file-name-extension buffer-file-name) "tsx")))
      (tide-setup)
      (flycheck-mode +1)
      (eldoc-mode +1)
      (setq tide-project-root (bmacs-project-root))))
  (add-hook 'typescript-mode #'+typescript|init-tide)
  (add-hook 'web-mode #'+typescript|init-tide))

#+END_SRC

*** Web

**** General

#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :commands (web-beautify-html web-beautify-css)
  :init
  (map! (:map* (css-mode-map scss-mode-map less-css-mode-map)
          :n "gQ" #'web-beautify-css)
        (:map* web-mode-map
          :n "gQ" #'web-beautify-html)))


(use-package emmet-mode
  :commands emmet-mode
  :preface (defvar emmet-mode-keymap (make-sparse-keymap))
  :init
  (add-hook 'css-mode #'emmet-mode)
  (add-hook 'web-mode #'emmet-mode)
  (add-hook 'html-mode #'emmet-mode)
  (add-hook 'haml-mode #'emmet-mode)
  (add-hook 'nxml-mode #'emmet-mode)
  (add-hook 'rjsx-mode #'emmet-mode)
  :config
  (setq emmet-move-cursor-between-quotes t)
  (map! :map emmet-mode-keymap
        :v "M-e" #'emmet-wrap-with-markup
        :i "M-e" #'emmet-expand-yas
        :i "M-E" #'emmet-expand-line))

#+END_SRC

**** Html

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.p?html?$"
  :mode "\\.\\(tpl\\|blade\\)\\(\\.php\\)?$"
  :mode "\\.erb$"
  :mode "\\.jsp$"
  :mode "\\.as[cp]x$"
  :mode "\\.mustache$"
  :mode "\\.tsx$"
  :mode "wp-content/themes/.+/.+\\.php$"
  :init
  (add-hook 'web-mode-hook #'turn-off-smartparens-mode)
  :config
  (add-hook 'web-mode-hook (lambda ()
                             (setq-local company-backends '(company-web-html company-yasnippet))))
  (setq web-mode-enable-html-entities-fontification t)

  (map! :map web-mode-map
        (:localleader
        :n "rt" #'web-mode-element-rename)
        "M-/" #'web-mode-comment-or-uncomment
        :i  "SPC" #'self-insert-command
        :n  "M-r" #'doom/web-refresh-browser
        :n  "za"  #'web-mode-fold-or-unfold
        :nv "]a"  #'web-mode-attribute-next
        :nv "[a"  #'web-mode-attribute-previous
        :nv "]t"  #'web-mode-tag-next
        :nv "[t"  #'web-mode-tag-previous
        :nv "]T"  #'web-mode-element-child
        :nv "[T"  #'web-mode-element-parent))

(use-package company-web
  :after web-mode)

(use-package haml-mode :mode "\\.haml$")

(use-package pug-mode
  :mode "\\.jade$"
  :mode "\\.pug$")
#+END_SRC

**** CSS

#+BEGIN_SRC emacs-lisp
(add-hook 'css-mode-hook #'rainbow-delimiters-mode)
(add-hook 'css-mode-hook #'(yas-minor-mode-on flycheck-mode highlight-numbers-mode))
(add-hook 'sass-mode-hook #'(yas-minor-mode-on flycheck-mode highlight-numbers-mode))

(sp-with-modes '(css-mode scss-mode less-css-mode stylus-mode)
  (sp-local-pair "/*" "*/" :post-handlers '(("[d-3]||\n[i]" "RET") ("| " "SPC"))))

(map! :map* (css-mode-map scss-mode-map less-css-mode-map)
      :n "M-R" #'+css/web-refresh-browser
      (:localleader
        :n  "rb" #'+css/toggle-inline-or-block))

(use-package rainbow-mode
  :commands rainbow-mode
  :init
  (add-hook 'css-mode #'rainbow-mode)
  (add-hook 'sass-mode #'rainbow-mode))

(use-package css-mode
  :mode "\\.css$"
  :mode ("\\.scss$" . scss-mode)
  :config
  (add-hook 'css-mode-hook #'(lambda ()
                               (setq-local company-backends '(company-css company-yasnippet))))
  (add-hook 'sass-mode-hook #'(lambda ()
                               (setq-local company-backends '(company-css company-yasnippet))))
  (map! :map scss-mode-map :localleader "b" #'+css/scss-build))

(use-package sass-mode
  :mode "\\.sass$"
  :config
  (map! :map scss-mode-map :localleader "b" #'+css/sass-build))

(use-package less-css-mode
  :mode "\\.less$")

(use-package stylus-mode
  :mode "\\.styl$"
  :init (add-hook! stylus-mode #'(yas-minor-mode-on flycheck-mode)))
#+END_SRC

** Misc

*** hydra
Emacs bindings that stick around

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :demand t
  :config
  (setq lv-use-seperator t)

  (defhydra doom@text-zoom (:hint t :color red)
    "
      Text zoom: _j_:zoom in, _k_:zoom out, _0_:reset
"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("0" (text-scale-set 0) "reset"))

  (defhydra doom@window-nav (:hint nil)
    "
          Split: _v_ert  _s_:horz
         Delete: _c_lose  _o_nly
  Switch Window: _h_:left  _j_:down  _k_:up  _l_:right
        Buffers: _p_revious  _n_ext  _b_:select  _f_ind-file
         Resize: _H_:splitter left  _J_:splitter down  _K_:splitter up  _L_:splitter right
           Move: _a_:up  _z_:down  _i_menu
"
    ("z" scroll-up-line)
    ("a" scroll-down-line)
    ("i" idomenu)

    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)

    ("p" doom/previous-buffer)
    ("n" doom/next-buffer)
    ("b" switch-to-buffer)
    ("f" find-file)

    ("s" split-window-below)
    ("v" split-window-right)

    ("c" delete-window)
    ("o" delete-other-windows)

    ("H" hydra-move-splitter-left)
    ("J" hydra-move-splitter-down)
    ("K" hydra-move-splitter-up)
    ("L" hydra-move-splitter-right)

    ("q" nil)))
#+END_SRC

*** command-log-mode
Log commands to buffer

#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :commands (command-log-mode global-command-log-mode)
  :config
  ;(set! :popup "*command-log*" :size 40 :align 'right :noselect t) TODO
  (setq command-log-mode-auto-show t
        command-log-mode-open-log-turns-on-mode t))
#+END_SRC

*** help-fns+
Improved help commands

#+BEGIN_SRC emacs-lisp
(use-package help-fns+
  :commands (describe-buffer describe-command describe-file
             describe-keymap describe-option describe-option-of-type))
#+END_SRC


*** TODO pcre2el

** Functions

*** File Functions

#+BEGIN_SRC emacs-lisp
  (defun bmacs/copy-file ()
    "Write the file under new name."
    (interactive)
    (call-interactively 'write-file))

  (defun bmacs/rename-file (filename &optional new-filename)
    "Rename FILENAME to NEW-FILENAME.

  When NEW-FILENAME is not specified, asks user for a new name.

  Also renames associated buffer (if any exists), invalidates
  projectile cache when it's possible and update recentf list."
    (interactive "f")
    (when (and filename (file-exists-p filename))
      (let* ((buffer (find-buffer-visiting filename))
             (short-name (file-name-nondirectory filename))
             (new-name (if new-filename new-filename
                         (read-file-name
                          (format "Rename %s to: " short-name)))))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (let ((dir (file-name-directory new-name)))
                 (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                   (make-directory dir t)))
               (rename-file filename new-name 1)
               (when buffer
                 (kill-buffer buffer)
                 (find-file new-name))
               (when (fboundp 'recentf-add-file)
                 (recentf-add-file new-name)
                 (recentf-remove-if-non-kept filename))
               (when (projectile-project-p)
                 (call-interactively #'projectile-invalidate-cache))
               (message "File '%s' successfully renamed to '%s'" short-name (file-name-nondirectory new-name)))))))

  (defun bmacs/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let* ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let* ((dir (file-name-directory filename))
               (new-name (read-file-name "New name: " dir)))
          (cond ((get-buffer new-name)
                 (error "A buffer named '%s' already exists!" new-name))
                (t
                 (let ((dir (file-name-directory new-name)))
                   (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                     (make-directory dir t)))
                 (rename-file filename new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil)
                 (when (fboundp 'recentf-add-file)
                     (recentf-add-file new-name)
                     (recentf-remove-if-non-kept filename))
                 (when (projectile-project-p)
                   (call-interactively #'projectile-invalidate-cache))
                 (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

  (defun bmacs/delete-file (filename &optional ask-user)
    "Remove specified file or directory.

  Also kills associated buffer (if any exists) and invalidates
  projectile cache when it's possible.

  When ASK-USER is non-nil, user will be asked to confirm file
  removal."
    (interactive "f")
    (when (and filename (file-exists-p filename))
      (let ((buffer (find-buffer-visiting filename)))
        (when buffer
          (kill-buffer buffer)))
      (when (or (not ask-user)
                (yes-or-no-p "Are you sure you want to delete this file? "))
        (delete-file filename)
        (when (projectile-project-p)
          (call-interactively #'projectile-invalidate-cache)))))

  (defun bmacs/delete-file-confirm (filename)
    "Remove specified file or directory after users approval.

  FILENAME is deleted using `bmacs/delete-file' function.."
    (interactive "f")
    (funcall-interactively #'bmacs/delete-file filename t))

  (defun bmacs/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to delete this file? ")
          (delete-file filename t)
          (kill-buffer buffer)
          (when (projectile-project-p)
            (call-interactively #'projectile-invalidate-cache))
          (message "File '%s' successfully removed" filename)))))

  (defun bmacs/sudo-edit (&optional arg)
    (interactive "P")
    (let ((fname (if (or arg (not buffer-file-name))
                     (read-file-name "File: ")
                   buffer-file-name)))
      (find-file
       (cond ((string-match-p "^/ssh:" fname)
              (with-temp-buffer
                (insert fname)
                (search-backward ":")
                (let ((last-match-end nil)
                      (last-ssh-hostname nil))
                  (while (string-match "@\\\([^:|]+\\\)" fname last-match-end)
                    (setq last-ssh-hostname (or (match-string 1 fname)
                                                last-ssh-hostname))
                    (setq last-match-end (match-end 0)))
                  (insert (format "|sudo:%s" (or last-ssh-hostname "localhost"))))
                (buffer-string)))
             (t (concat "/sudo:root@localhost:" fname))))))

  (defun bmacs/show-and-copy-buffer-filename ()
    "Show and copy the full path to the current file in the minibuffer."
    (interactive)
    ;; list-buffers-directory is the variable set in dired buffers
    (let ((file-name (or (buffer-file-name) list-buffers-directory)))
      (if file-name
          (progn
            (kill-new file-name)
            (message file-name))
        (error "Buffer not visiting a file"))))

  ;; (defun bmacs/alternate-buffer (&optional window)
  ;;   "Switch back and forth between current and last buffer in the
  ;; current window."
  ;;   (interactive)
  ;;   (let ((current-buffer (window-buffer window))
  ;;         (buffer-predicate
  ;;          (frame-parameter (window-frame window) 'buffer-predicate)))
  ;;     ;; switch to first buffer previously shown in this window that matches
  ;;     ;; frame-parameter `buffer-predicate'
  ;;     (switch-to-buffer
  ;;      (or (cl-find-if (lambda (buffer)
  ;;                        (and (not (eq buffer current-buffer))
  ;;                             (or (null buffer-predicate)
  ;;                                 (funcall buffer-predicate buffer))))
  ;;                      (mapcar #'car (window-prev-buffers window)))
  ;;          ;; `other-buffer' honors `buffer-predicate' so no need to filter
  ;;          (other-buffer current-buffer t)))))

  ;; TODO: make better ... not window specific
  (defun bmacs/alternate-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (defun bmacs/toggle-fold ()
    (interactive)
    (save-excursion
      (end-of-line)
      (hs-toggle-hiding)))

  (defun bmacs/toggle-whitespace ()
    (interactive)
    (if (and (boundp 'whitespace-mode) whitespace-mode)
        (whitespace-mode -1)
      (whitespace-mode +1)))

  (defun bmacs/sudo-find-file (file)
    "Open a file as root."
    (interactive
     (list (read-file-name "Open as root: ")))
    (find-file (if (file-writable-p file)
                   file
                 (concat "/sudo:root@localhost:" file))))

  (defun bmacs/sudo-this-file ()
    "Open the current file as root."
    (interactive)
    (bmacs/sudo-find-file (file-truename buffer-file-name)))
#+END_SRC

*** Buffer Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/kill-buffer-and-windows (buffer)
  "Kill the buffer and delete all the windows it's displayed in."
  (dolist (window (get-buffer-window-list buffer))
    (unless (one-window-p t)
      (delete-window window)))
  (kill-buffer buffer))

(defun bmacs/kill-other-buffers (&optional persp-p)
  "Kill all other buffers (besides the current one).

If PROJECT-P (universal argument), kill only buffers that belong to the current
project."
  (interactive "P")
  (let ((buffers (if persp-p (persp-buffer-list) (buffer-list)))
        (current-buffer (current-buffer)))
    (dolist (buf buffers)
      (unless (eq buf current-buffer)
        (bmacs/kill-buffer-and-windows buf)))
    (when (called-interactively-p 'interactive)
      (message "Killed %s buffers" (length buffers)))))
#+END_SRC

*** Counsel Project Bookmarks

#+BEGIN_SRC emacs-lisp
(defun counsel-projectile-bookmark ()
    "Forward to `bookmark-jump' or `bookmark-set' if bookmark doesn't exist."
    (interactive)
    (require 'bookmark)
    (let ((projectile-bookmarks (projectile-bookmarks)))
      (ivy-read "Create or jump to bookmark: "
                projectile-bookmarks
                :action (lambda (x)
                          (cond ((and counsel-bookmark-avoid-dired
                                      (member x projectile-bookmarks)
                                      (file-directory-p (bookmark-location x)))
                                 (with-ivy-window
                                   (let ((default-directory (bookmark-location x)))
                                     (counsel-find-file))))
                                ((member x projectile-bookmarks)
                                 (with-ivy-window
                                   (bookmark-jump x)))
                                (t
                                 (bookmark-set x))))
                :caller 'counsel-projectile-bookmark)))

  (ivy-set-actions
   'counsel-projectile-bookmark
   '(("d" bookmark-delete "delete")
     ("e" bookmark-rename "edit")))

  (defun projectile-bookmarks ()
    (let ((bmarks (bookmark-all-names)))
      (remove-if-not #'workspace-bookmark-p bmarks)))

  (defun workspace-bookmark-p (bmark)
    (let ((bmark-path (expand-file-name (bookmark-location bmark))))
      (string-prefix-p (bmacs-project-root) bmark-path)))
#+END_SRC

*** Random Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/delete-git-index-lock ()
  "Deletes index.lock file for git project if it exists"
  (interactive)
  (let ((git-index-lock-file (concat (magit-git-dir) "index.lock")))
    (when (file-exists-p git-index-lock-file)
      (delete-file git-index-lock-file))))

;;;###autoload
(defun bmacs/ace-delete-window-dispatch ()
  "Invokes ace-delete window with aw-dispatch-always temporarily set to true"
  (interactive)
  (let ((aw-dispatch-always t))
    (call-interactively #'ace-delete-window)))

;;;###autoload
(defun bmacs/file-as-string (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))

;;;###autoload
(defun bmacs/set-limit-fill-column ()
  (interactive)
  (let ((column (string-to-number
                 (read-string "Fill Column: "))))
    (when (> column 0)
      (setq-local fill-column 120)
      (visual-line-mode +1)
      (auto-fill-mode -1)
      (visual-fill-column-mode +1))))

;;;###autoload
(defun bmacs/set-limit-auto-fill-column ()
  (interactive)
  (let ((column (string-to-number
                 (read-string "Fill Column: "))))
    (when (> column 0)
      (setq-local fill-column column)
      (visual-line-mode +1)
      (auto-fill-mode +1)
      (visual-fill-column-mode +1))))

;;;###autoload
(defun bmacs/disable-all-fill-column ()
  (interactive)
  (visual-line-mode -1)
  (auto-fill-mode -1)
  (visual-fill-column-mode -1))
#+END_SRC

** Keybindings
Whoa Nelly!

#+BEGIN_SRC emacs-lisp
(defmacro +ivy-do-action! (action)
  "A factory function that returns an interactive lamba that sets the current
ivy action and immediately runs it on the current candidate (ending the ivy
session)."
  `(lambda ()
     (interactive)
     (ivy-set-action ,action)
     (setq ivy-exit 'done)
     (exit-minibuffer)))

(defmacro find-file-in! (path &optional project-p)
  "Returns a interactive function for searching files"
  `(lambda () (interactive)
     (let ((default-directory ,path))
       (call-interactively
        ',(if project-p
              (command-remapping 'projectile-find-file)
            (command-remapping 'find-file))))))

(define-key input-decode-map [?\C-i] [C-i])

(map!
 ;; Essential
 "M-x"    #'execute-extended-command
 "M-;"    #'eval-expression
 ;; Tools
 ;"C-`"    #'doom/popup-toggle ; TODO
 ;; Text-scaling
 "M-0"    (lambda () (text-scale-set 0))
 "M-="    #'text-scale-increase
 "M--"    #'text-scale-decrease
 ;; Temporary escape into emacs mode
 :e [C-escape] #'evil-normal-state
 :n [C-escape] #'evil-emacs-state
 ;; Indent on tab
 :nvi "TAB"     #'indent-for-tab-command
 ;; Fold toggle
 :nv [C-backspace] #'bmacs/toggle-fold
 :nv [S-backspace] #'hs-hide-level
 :nv [C-S-backspace] #'hs-show-all

  :m ";" #'evil-ex
  (:leader
    ;; common
    :desc "Blink cursor line"                :nv "SPC" #'bmacs/blink-cursor
    :desc "Counsel M-x"                      :nv ":" #'counsel-M-x
    :desc "Eval expr"                        :nv ";" #'eval-expression
    :desc "Run shell command"                :nv "!" #'shell-command
    :desc "Search in project"                :nv "/" #'counsel-projectile-rg
    :desc "Search from here"                 :nv "?" #'counsel-rg
    :desc "Find selection in project"        :nv "*" #'counsel-projectile-rg-region-or-symbol
    :desc "Switch to Emacs mode"             :n "|" #'evil-emacs-state
    :desc "Switch to last buffer"            :nv "TAB" #'bmacs/alternate-buffer
    :desc "Ace window"                       :nv "W" #'ace-window
    :desc "Pop terminal"                     :nv "'" #'+term/open-popup
    :desc "Pop eshell"                       :nv "`" #'+eshell/open-popup

    (:desc "file"
      :prefix "f"
      :desc "Open file from here"            :nv "f" #'counsel-find-file
      :desc "Sudo open file from here"       :nv "F" #'bmacs/sudo-find-file
      :desc "Copy file"                      :nv "c" #'copy-file
      :desc "Copy current file"              :nv "C" #'bmacs/copy-file
      :desc "Rename current file"            :nv "R" #'bmacs/rename-current-buffer-file
      :desc "Delete file"                    :nv "d" #'bmacs/delete-file-confirm
      :desc "Delete current file"            :nv "D" #'bmacs/delete-current-buffer-file
      :desc "Sudo edit file"                 :nv "E" #'bmacs/sudo-edit
      :desc "Recent files"                   :nv "r"  #'counsel-recentf
      :desc "Neotree toggle"                 :nv "t"  #'neotree-toggle
      :desc "Save buffer"                    :nv "s"  #'save-buffer
      :desc "Save all buffers"               :nv "S"  #'evil-write-all
      :desc "Counsel bookmark"               :nv "b"  #'counsel-bookmark
      :desc "Remote"                         :nv "i"  (lambda ()
                                                        (interactive)
                                                        (counsel-find-file "/"))
      :desc "Cleanup this tramp conn"        :nv "x" #'tramp-cleanup-this-connection
      :desc "Cleanup all tramp conns"        :nv "X" (lambda ()
                                                       (interactive)
                                                       (tramp-cleanup-all-buffers)
                                                       (tramp-cleanup-all-connections))
      :desc "Show and copy filename"         :nv "y" #'bmacs/show-and-copy-buffer-filename
      )

    (:desc "buffer"
      :prefix "b"
      :desc "Select entire buffer"           :nv "a" #'mark-whole-buffer
      :desc "Switch workspace buffer"        :nv "b" #'projectile-switch-to-buffer
      :desc "Switch buffer"                  :nv "B" #'ivy-switch-buffer
      :desc "Kill buffer"                    :nv "d" #'kill-this-buffer
      :desc "Kill other buffers"             :nv "D" (lambda ()
                                                       (interactive)
                                                       (bmacs/kill-other-buffers t))
      :desc "Kill a buffer"                  :nv "k" #'kill-buffer
      :desc "New empty buffer"               :nv "n" #'evil-buffer-new
      ;; :desc "Scratch buffer"                 :nv "s" #'doom/open-scratch-buffer TODO
      ;; TODO spacemacs/copy-whole-buffer-to-clipboard y
      ;; TODO spacemacs/paste-whole-file-to-clipboard p
      )

    (:desc "ivy"
      :prefix "i"
      :desc "Ivy resume"                    :nv "r" #'ivy-resume)

    (:desc "project"
      :prefix "p"
      :desc "Find file in project"          :nv "f" #'counsel-projectile-find-file
      :desc "Run cmd in project root"       :nv "!" #'projectile-run-shell-command-in-root
      :desc "Toggle project neotree"        :nv "t" #'+neotree/toggle
      :desc "Switch project"                :nv "p" #'counsel-projectile-switch-project
      :desc "Switch project workspace"      :nv "l" #'+workspace-switch-project
      :desc "Kill project buffers"          :nv "k" #'projectile-kill-buffers
      :desc "Recent project files"          :nv "r" #'projectile-recentf
      :desc "Invalidate cache"              :nv "I" #'projectile-invalidate-cache
      :desc "List project tasks"            :nv "a" #'+ivy/tasks
      :desc "Pop term in project root"      :nv "'" #'+term/open-popup-in-project
      :desc "Project specific bookmarks"    :nv "b" #'counsel-projectile-bookmark)

    (:desc "search"
      :prefix "s"
      :desc "IEdit mode"                    :nv "e" #'evil-iedit-state/iedit-mode
      :desc "Swiper search"                 :nv "s" #'swiper
      :desc "Search online"                 :nv "o" #'+search/online
      :desc "Search online same source"     :nv "O" #'+search/online-use-last)

    (:desc "workspace"
      :prefix "l"
      :desc "Switch to workspace"          :nv "l" #'persp-switch
      :desc "Save workspace state"         :nv "s" #'persp-save-state-to-file
      :desc "Switch last workspace"        :nv "TAB" #'+workspace-switch-last
      :desc "Kill workspace"               :nv "d" #'persp-kill)

    (:desc "window"
      :prefix "w"
      :desc "Split window vertical"        :nv "/" #'split-window-right
      :desc "Split window horizontal"      :nv "-" #'split-window-below
      :desc "Balance windows"              :nv "=" #'balance-windows
      :desc "Delete current window"        :nv "d" #'delete-window
      :desc "Ace delete window"            :nv "D" #'bmacs/ace-delete-window-dispatch
      :desc "Window left"                  :nv "h" #'evil-window-left
      :desc "Window down"                  :nv "j" #'evil-window-down
      :desc "Window right"                 :nv "l" #'evil-window-right
      :desc "Window up"                    :nv "k" #'evil-window-up
      :desc "Move window left"             :nv "H" #'evil-window-move-far-left
      :desc "Move window down"             :nv "J" #'evil-window-move-very-bottom
      :desc "Move window right"            :nv "L" #'evil-window-move-far-right
      :desc "Move window up"               :nv "K" #'evil-window-move-very-top
      :desc "Ace swap window"              :nv "s" #'ace-swap-window
      :desc "Winner undo"                  :nv "u" #'winner-undo
      :desc "Winner redo"                  :nv "U" #'winner-redo
      :desc "Ace window"                   :nv "w" #'ace-window
      :desc "Toggle maximize window"       :nv "m" #'doom/window-zoom)

    (:desc "jump"
      :prefix "j"
      :desc "Go definition"                :nv "q" #'bmacs/jump-definition
      :desc "Go definition other window"   :nv "Q" #'bmacs/jump-definition-other-window
      :desc "Avy go to line"               :nv "l" #'avy-goto-line
      :desc "Avy go to word"               :nv "w" #'evil-avy-goto-word-or-subword-1
      :desc "Avy go to char"               :nv "j" #'avy-goto-char-2
      :desc "Lookup online"                :nv "o" #'+jump/online
      :desc "Lookup online same source"    :nv "O" #'+jump/online-use-last)

    (:desc "git"
      :prefix "g"
      :desc "Git status"                   :nv "s" #'magit-status
      :desc "Git blame"                    :nv "b" #'magit-blame
      :desc "Git time machine"             :nv "t" #'git-timemachine
      :desc "Git log file"                 :nv "l" #'magit-log-buffer-file
      :desc "Show and copy git link"       :nv "y" #'git-link
      :desc "Open git link"                :nv "o" #'bmacs/git-browse
      :desc "Delete git index lock"        :nv "X" #'bmacs/delete-git-index-lock
      (:desc "gist"
        :prefix "g"
        :desc "Gist from buffer"           :nv "b" #'gist-buffer
        :desc "Private gist from buffer"   :nv "B" #'gist-buffer-private
        :desc "Gist from region"           :nv "r" #'gist-region
        :desc "Private gist from region"   :nv "R" #'gist-region-private
        :desc "List gists"                 :nv "l" #'gist-list))

    (:desc "open"
      :prefix "o"
      :desc "Organizer"                    :nv "o" #'+borg/open-organizer
      :desc "Agenda"                       :nv "a" #'org-agenda
      :desc "Org capture"                  :nv "c" #'org-capture
      :desc "Email"                        :nv "e" #'=email)

    (:desc "quit"
     :prefix "q"
     :desc "Quit"                          :nv "q" #'evil-save-and-quit)

   (:desc "toggle"
     :prefix "z"
     :desc "Text size increase"            :nv "+" #'text-scale-increase
     :desc "Text size decrease"            :nv "+" #'text-scale-decrease
     :desc "Spell check"                   :nv "s" #'flyspell-mode
     :desc "Line numbers"                  :nv "l" #'doom/toggle-line-numbers
     :desc "Indent guides"                 :nv "i" #'highlight-indentation-mode
     :desc "Indent guides (column)"        :nv "I" #'highlight-indentation-current-column-mode
     :desc "Evil goggles"                  :nv "g" #'+evil-goggles/toggle
     :desc "Visual line wrapping"          :nv "v" #'visual-line-mode
     :desc "Whitespace mode"               :nv "w" #'gdoom/toggle-whitespace)

   (:desc "text"
     :prefix "t"
     :desc "Regular expression builder"    :nv "r" #'regexp-builder
     (:desc "fill"
       :prefix "f"
       :desc "Limit fill column"           :nv "l" #'bmacs/set-limit-fill-column
       :desc "Auto limit fill column"      :nv "a" #'bmacs/set-limit-fill-column
       :desc "Disable fill column limit"   :nv "d" #'bmacs/disable-all-fill-column)
     (:desc "html"
       :prefix "h"
       :desc "Copy region as html"         :v "y" #'gdoom/htmlize-region-copy))

   (:desc "code"
     :prefix "c"
     :desc "Build"                         :nv "b" #'+eval/build
     :desc "Open/Send to REPL"             :nv "r" #'+eval/repl
     :desc "Open debugger"                 :nv "R" #'+debug/open
     :desc "Counsel dash"                  :nv "d" #'counsel-dash
     :desc "Dash install docset"           :nv "i" #'counsel-dash-install-docset))

 ;; Works when I accidentally use tmux bindings
 (:desc "tmux emulation"
   :prefix "C-b"
   :desc "Window left"                     :nv "h" #'evil-window-left
   :desc "Window down"                     :nv "j" #'evil-window-down
   :desc "Window right"                    :nv "l" #'evil-window-right
   :desc "Window up"                       :nv "k" #'evil-window-up
   :desc "Delete current window"           :nv "x" #'delete-window
   :desc "Split window vertical"           :nv "/" #'split-window-right
   :desc "Split window horizontal"         :nv "-" #'split-window-below)

 ;;; Evil-esque bindings
 ;;; indent on new line
 :i "RET" #'evil-ret-and-indent
 ;; Yank to EOL
 :n  "Y"  "y$"
 ;; Repeat in visual mode (buggy)
 :v  "."  #'evil-repeat
 :v  "<"  #'+evil/visual-dedent     ; vnoremap < <gv
 :v  ">"  #'+evil/visual-indent     ; vnoremap > >gv
 ;; undo/redo for regions (buggy)
 :nv "u"   #'undo-tree-undo
 :nv "C-r" #'undo-tree-redo
 ;; without yank commands
 :n  "c"  #'evil-change-without-register
 :n  "C"  #'evil-change-line-without-register
 :n  "p"  #'evil-paste-after-without-register
 :n  "P"  #'evil-paste-before-without-register
 :n  "x"  #'evil-delete-char-without-register
 :n  "X"  #'evil-delete-backward-char-without-register
 :n  "d"  #'evil-delete-without-register-if-whitespace
 ;; simple motions
 :nv "H"  #'evil-first-non-blank
 :nv "L"  #'evil-last-non-blank
 ;; search avy goto
 :nv "C-f"  #'avy-goto-char-timer

 (:map evil-window-map ; prefix "C-w"
   ;; Navigation
   "C-h"     #'evil-window-left
   "C-j"     #'evil-window-down
   "C-k"     #'evil-window-up
   "C-l"     #'evil-window-right
   "C-w"     #'ace-window
   ;; Swapping windows
   "H"       #'+evil/window-move-left
   "J"       #'+evil/window-move-down
   "K"       #'+evil/window-move-up
   "L"       #'+evil/window-move-right
   "C-S-w"   #'ace-swap-window
   ;; Window undo/redo
   "u"       #'winner-undo
   "C-u"     #'winner-undo
   "C-r"     #'winner-redo
   "o"       #'doom/window-zoom
   ;; Delete window
   "C-C"     #'ace-delete-window)

 ;; help-mode
 (:map help-mode-map
   :n "]]"  #'help-go-forward
   :n "[["  #'help-go-back
   :n "o"   #'ace-link-help)

 ;; --- Plugin bindings ------------------------------
 ;; auto-yasnippet
 :i  [C-tab] #'aya-expand
 :nv [C-tab] #'aya-create

 ;; company-mode (+ vim-like omnicompletion)
 :i "C-SPC"  #'+company/complete

 (:after evil-mc
   (:map evil-mc-key-map
     "C-S-j"          #'evil-mc-make-cursor-move-next-line
     "C-S-k"          #'evil-mc-make-cursor-move-prev-line
     [M-down-mouse-1] #'evil-mc-toggle-cursor-on-click))

 (:after company
   (:map company-active-map
     ;; Don't interfere with `evil-delete-backward-word' in insert mode
     "C-w"           nil
     "C-o"           #'company-search-kill-others
     "C-n"           #'company-select-next
     "C-p"           #'company-select-previous
     "C-j"           #'company-select-next
     "C-k"           #'company-select-previous
     "C-h"           #'company-quickhelp-manual-begin
     "C-S-h"         #'company-show-doc-buffer
     "C-S-s"         #'company-search-candidates
     "C-s"           #'company-filter-candidates
     [enter]         #'company-complete-common
     "C-h"           #'company-quickhelp-manual-begin
     "C-g"           #'company-abort
     [tab]           #'company-complete-common-or-cycle
     [backtab]       #'company-select-previous
     [escape]        (lambda () (company-abort) (evil-normal-state 1)))
   ;; Automatically applies to `company-filter-map'
   (:map company-search-map
     "C-j"        #'company-search-repeat-forward
     "C-k"        #'company-search-repeat-backward
     "C-s"        (lambda () (company-search-abort) (company-filter-candidates))
     [escape]     #'company-search-abort))

 ;; counsel
 (:after counsel
   :map counsel-ag-map
   [backtab] #'+ivy/wgrep-occur  ; search/replace on results
   "C-SPC"   #'counsel-git-grep-recenter   ; preview
   "M-RET"   (+ivy-do-action! #'+ivy-git-grep-other-window-action))

 ;; evil-commentary
 :n  "gc" #'evil-commentary

 ;; evil-exchange
 :n  "gx" #'evil-exchange

 ;; evil-snipe
 (:after evil-snipe
   ;; Binding to switch to evil-easymotion/avy after a snipe
   (:map evil-snipe-parent-transient-map
     "C-;" (lambda () (require 'evil-easymotion)
               (call-interactively +evil--snipe-repeat-fn))))

 ;; avy goto char
 :n "s"   #'avy-goto-char-2

 ;; evil-surround
 :v  "s"  #'evil-surround-region
 :o  "s"  #'evil-surround-edit
 :o  "S"  #'evil-Surround-edit

 ;; expand-region
 :v  "v"  #'er/expand-region
 :v  "V"  #'er/contract-region

 ;; flycheck
 :m  "]e" #'next-error
 :m  "[e" #'previous-error

 ;; save buffer (but don't close window)
 :n "zz"  #'save-buffer

 (:after flycheck
   (:map flycheck-error-list-mode-map
     :n "C-n" #'flycheck-error-list-next-error
     :n "C-p" #'flycheck-error-list-previous-error
     :n "j"   #'flycheck-error-list-next-error

     :n "RET" #'flycheck-error-list-goto-error))

 ;; flyspell
 :m  "]S" #'flyspell-correct-word-generic
 :m  "[S" #'flyspell-correct-previous-word-generic

 ;; git-gutter
 :m  "]d" #'git-gutter:next-hunk
 :m  "[d" #'git-gutter:previous-hunk

 ;; git-timemachine
 (:after git-timemachine
   (:map git-timemachine-mode-map
     :nv "p" #'git-timemachine-show-previous-revision
     :nv "n" #'git-timemachine-show-next-revision
     :nv "g" #'git-timemachine-show-nth-revision
     :nv "q" #'git-timemachine-quit
     :nv "w" #'git-timemachine-kill-abbreviated-revision
     :nv "W" #'git-timemachine-kill-revision
     :nv "b" #'git-timemachine-blame))

 ;; gist
 (:after gist
   (:map gist-list-menu-mode-map
     :n "RET" #'+gist/open-current
     :n "b"   #'gist-browse-current-url
     :n "c"   #'gist-add-buffer
     :n "d"   #'gist-kill-current
     :n "f"   #'gist-fork
     :n "q"   #'quit-window
     :n "r"   #'gist-list-reload
     :n "s"   #'gist-star
     :n "S"   #'gist-unstar
     :n "y"   #'gist-print-current-url))

 ;; hl-todo
 :m  "]t" #'hl-todo-next
 :m  "[t" #'hl-todo-previous

 ;; ivy
 (:after ivy
   (:map ivy-minibuffer-map
     [escape] #'keyboard-escape-quit
     "C-y" #'yank
     "M-v" #'yank
     "M-z" #'undo
     "C-r" #'evil-paste-from-register
     "C-h" (kbd "DEL")
     "C-k" #'ivy-previous-line
     "C-j" #'ivy-next-line
     "C-l" #'ivy-alt-done
     "C-w" #'+ivy/backward-kill-word
     "C-u" #'doom/minibuffer-kill-line
     "C-b" #'backward-word
     "C-f" #'forward-word
     "C-o" #'ivy-dispatching-done
     "<C-return>" #'ivy-immediate-done
     "C-S-h k" #'describe-key
     "C-S-h f" #'describe-function
     "C-S-h v" #'describe-variable)
   (:map ivy-occur-grep-mode-map
     (:desc "ivy occur actions"
       :prefix ","
       :desc "switch to ivy wgrep mode"    :n "," 'ivy-wgrep-change-to-wgrep-mode
       :desc "switch to ivy wgrep mode"    :n "w" 'ivy-wgrep-change-to-wgrep-mode)))

 ;; neotree
 (:after neotree
   (:map neotree-mode-map
     :n "g"         nil
     :n [tab]       #'neotree-quick-look
     :n "RET"       #'neotree-enter
     :n [backspace] #'evil-window-prev
     :n "j"         #'neotree-next-line
     :n "k"         #'neotree-previous-line
     :n "n"         #'neotree-next-line
     :n "p"         #'neotree-previous-line
     :n "h"         #'+neotree/collapse-or-up
     :n "l"         #'+neotree/expand-or-open
     :n "J"         #'neotree-select-next-sibling-node
     :n "K"         #'neotree-select-previous-sibling-node
     :n "H"         #'neotree-select-up-node
     :n "L"         #'neotree-select-down-node
     :n "c"         #'neotree-create-node
     :n "r"         #'neotree-rename-node
     :n "d"         #'neotree-delete-node
     :n "G"         #'evil-goto-line
     :n "gg"        #'evil-goto-first-line
     :n "v"         #'neotree-enter-vertical-split
     :n "s"         #'neotree-enter-horizontal-split
     :n "q"         #'neotree-hide
     :n "R"         #'neotree-refresh))

 ;; realgud
 (:after realgud
   (:map realgud:shortkey-mode-map
     :n "j" #'evil-next-line
     :n "k" #'evil-previous-line
     :n "h" #'evil-backward-char
     :n "l" #'evil-forward-char
     :m "n" #'realgud:cmd-next
     :m "b" #'realgud:cmd-break
     :m "B" #'realgud:cmd-clear
     :n "c" #'realgud:cmd-continue))

 ;; rotate-text
 :n  "!"  #'rotate-text

 ;; smart-forward
 :nv "C-k"  #'smart-up
 :nv "C-j"  #'smart-down

 ;; evil visual restore
 :n "gv" #'evil-visual-restore

 ;; move selection
 :v "J" (concat ":m '>+1" (kbd "RET") "gv=gv")
 :v "K" (concat ":m '<-2" (kbd "RET") "gv=gv")

 :n "K" #'evil-previous-line

 ;; undo-tree -- undo/redo for visual regions
 :v "C-r" #'undo-tree-redo

 ;; yasnippet
 (:after yasnippet
   (:map yas-keymap
     [tab]           #'yas-next-field
     "C-e"           #'+snippets/goto-end-of-field
     "C-a"           #'+snippets/goto-start-of-field
     "<M-right>"     #'+snippets/goto-end-of-field
     "<M-left>"      #'+snippets/goto-start-of-field
     "<M-backspace>" #'+snippets/delete-to-start-of-field
     [escape]        #'evil-normal-state
     [backspace]     #'+snippets/delete-backward-char
     [delete]        #'+snippets/delete-forward-char-or-field)
   (:map yas-minor-mode-map
     :i "M-SPC" #'yas-expand)))


;;
;; Keybinding fixes
;;

;; This section is dedicated to "fixing" certain keys so that they behave
;; properly, more like vim, or how I like it.

(map! (:map input-decode-map
        [?\C-i] [C-i]
        [S-iso-lefttab] [backtab]
        (:unless window-system "TAB" [tab])) ; Fix TAB in terminal

      :niv "<C-i>" #'evil-jump-forward

      ;; I want C-a and C-e to be a little smarter. C-a will jump to
      ;; indentation. Pressing it again will send you to the true bol. Same goes
      ;; for C-e, except it will ignore comments and trailing whitespace before
      ;; jumping to eol.
      :i "C-a" #'doom/backward-to-bol-or-indent
      :i "C-e" #'doom/forward-to-last-non-comment-or-eol
      :i "C-u" #'doom/backward-kill-to-bol-and-indent

      ;; textmate-esque newline insertion
      :i [C-return]     #'evil-open-below
      :i [S-C-return]   #'evil-open-above
      ;; textmate-esque deletion
      [C-backspace]     #'doom/backward-kill-to-bol-and-indent
      :i [backspace]    #'delete-backward-char
      :i [C-backspace]  #'doom/backward-kill-to-bol-and-indent
      ;; Emacsien motions for insert mode
      :i "C-b" #'backward-word
      :i "C-f" #'forward-word

      :i [remap newline]                #'doom/newline-and-indent

      ;; Make ESC quit all the things
      (:map (minibuffer-local-map
             minibuffer-local-ns-map
             minibuffer-local-completion-map
             minibuffer-local-must-match-map
             minibuffer-local-isearch-map)
        [escape] #'abort-recursive-edit
        "C-r" #'evil-paste-from-register)

      (:map messages-buffer-mode-map
        "M-;" #'eval-expression
        "A-;" #'eval-expression)

      (:map tabulated-list-mode-map
        [remap evil-record-macro] #'doom/popup-close-maybe)

      (:map (evil-ex-completion-map evil-ex-search-keymap read-expression-map)
        "C-a" #'move-beginning-of-line
        "C-w" #'doom/minibuffer-kill-word
        "C-u" #'doom/minibuffer-kill-line
        "C-b" #'backward-word
        "C-f" #'forward-word
        "M-z" #'doom/minibuffer-undo)

      (:after view
        (:map view-mode-map "<escape>" #'View-quit-all)))
#+END_SRC

** Post Init

*** Run Post Init Hook

#+BEGIN_SRC emacs-lisp
(run-hooks 'bmacs-post-init-hook)
#+END_SRC

*** Web Browser
Open url links in qutebrowser

#+BEGIN_SRC emacs-lisp
(defun gilbertw1/browse-url (url &optional ignored)
  (interactive (browse-url-interactive-arg "URL: "))
  (call-process "/home/gilbertw1/bin/open-qutebrowser" nil 0 nil url))
(setq browse-url-browser-function #'gilbertw1/browse-url)

(defun gilbertw1/browse-url-new-window (url &optional ignored)
  (call-process "qutebrowser" nil 0 nil "--target" "window" url))
(setq counsel-dash-browser-func #'gilbertw1/browse-url-new-window)
#+END_SRC

*** Indentation
Set the various indentations

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2
              c-basic-offset 4
              coffee-tab-width 2
              javascript-2-level 2
              js-2-level 2
              js2-basic-offset 2
              web-mode-markup-2-offset 2
              web-mode-css-2-offset 2
              web-mode-code-2-offset 2
              css-2-offset 2
              rust-indent-offset 4)

(add-hook 'js2-mode-hook (lambda ()
                           (setq js2-basic-offset 2)))
#+END_SRC

*** Adjust Fringe

#+BEGIN_SRC emacs-lisp
(fringe-mode '(12 . 12))
#+END_SRC

*** Update Faces

#+BEGIN_SRC emacs-lisp
;; Override vc modified color (gray -> yellow)
(custom-set-faces
  '(diff-hl-change         ((t (:foreground "#ECBE7B"))))
  '(git-gutter:modified    ((t (:foreground "#ECBE7B"))))
  '(git-gutter+-modified   ((t (:foreground "#ECBE7B"))))
  '(git-gutter-fr:modified ((t (:foreground "#ECBE7B")))))

;; Override smerge colors
(custom-set-faces
  '(smerge-refined-removed ((t (:inherit 'smerge-mine))))
  '(smerge-refined-added   ((t (:inherit 'smerge-other)))))

;; Override evil googles colors
(custom-set-faces
 '(evil-goggles-delete-face           ((t (:foreground "#ff6c6b"))))
 '(evil-goggles-paste-face            ((t (:foreground "#98be65"))))
 '(evil-goggles-yank-face             ((t (:foreground "#51afef"))))
 '(evil-goggles-undo-redo-remove-face ((t (:foreground "#ff6c6b"))))
 '(evil-goggles-undo-redo-add-face    ((t (:foreground "#98be65"))))
 '(evil-goggles-undo-redo-change-face ((t (:foreground "#51afef")))))

;; Override org mode colors
(custom-set-faces
 '(org-level-1              ((t :foreground "#51afef" :inherit nil :height 1.2)))
 '(org-level-2              ((t :foreground "#DCAEEA" :inherit nil :height 1.1)))
 '(org-level-3              ((t :foreground "#a9a1e1" :inherit nil :height 1.1)))
 '(org-level-4              ((t :foreground "#ECBE7B" :inherit nil :height 1.1)))
 '(org-level-5              ((t :foreground "#46D9FF" :inherit nil :height 1.1))))
#+END_SRC

*** Mardown Open Comamnd

#+BEGIN_SRC emacs-lisp
(setq markdown-open-command "typora")
#+END_SRC
